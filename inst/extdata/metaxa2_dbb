#!/usr/bin/perl
# Metaxa2 Database Builder
$app_title     = "Metaxa2 Database Builder -- Automatic database creation for Metaxa2";
$app_author    = "Johan Bengtsson-Palme, University of Gothenburg";
$app_version   = "2.2";
$app_message   = "";
# ----------------------------------------------------------------- #

# License information
$license =
  "    metaxa2_dbb - Metaxa2 Database Builder -- Automatic database creation for Metaxa2\
    Copyright (C) 2016-2018 Johan Bengtsson-Palme & Rodney Richardson\
\
    This program is free software: you can redistribute it and/or modify\
    it under the terms of the GNU General Public License as published by\
    the Free Software Foundation, either version 3 of the License, or\
    (at your option) any later version.\
\
    This program is distributed in the hope that it will be useful,\
    but WITHOUT ANY WARRANTY; without even the implied warranty of\
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\
    GNU General Public License for more details.\
\
    You should have received a copy of the GNU General Public License\
    along with this program, in a file called 'license.txt'\
    If not, see: http://www.gnu.org/licenses/.\
";

## BUGS:
$bugs = "New features in this version ($app_version):\
- Initial release.\
\
Fixed bugs in this version ($app_version):\
- None\
\
Known bugs in this version ($app_version):\
- None\
";

## OPTIONS:
$options = "\
-i {file} : DNA FASTA file containing the reference sequences of a single gene to be used for classification (overrides specific input options below)\
-o {directory} : Directory name for the output files\
-g {string} : Gene name for the database\
-p {directory} : Use HMMs from the specified directory instead of computing new ones (i.e. only build a new classification database), not used by default\
-t {file} : Taxonomy file containing taxonomic information to be parsed in any of the following formats:\
            Metaxa2, FASTA, ASN1, NCBI XML, INSD XML\
-r {sequence_ID} : ID of the sequence that should be used as the representative sequence of the gene\
                   if blank, the first sequence in the input file is used\
--auto_rep {T or F} : Choose a reference sequence automatically (requires Usearch to be installed), on (T) by default\
--cpu {integer} : Number of CPUs to use (will be passed on to other programs), default = 1\
--save_raw {T or F} : Keep intermediate files after the program finishes, off (F) by default\
--plus {T or F} : Use BLAST+ instead of legacy BLAST, off (F) by default\


-a {file} : DNA FASTA file containing archaeal reference sequences to be used for classification (cannot be combined with the -i option)\
-b {file} : DNA FASTA file containing bacterial reference sequences to be used for classification (cannot be combined with the -i option)\
-c {file} : DNA FASTA file containing chloroplast reference sequences to be used for classification (cannot be combined with the -i option)\
-e {file} : DNA FASTA file containing eukaryote reference sequences to be used for classification (cannot be combined with the -i option)\
-m {file} : DNA FASTA file containing mitochondrial reference sequences to be used for classification (cannot be combined with the -i option)\
-n {file} : DNA FASTA file containing metazoan mitochondrial reference sequences to be used for classification (cannot be combined with the -i option)\
--other {file} : DNA FASTA file containing reference sequences of other origins to be used for classification (cannot be combined with the -i option)\

--full_length {integer} : number of basepairs to use for full-length definition (set to zero to disable full-length extraction), default = 100\
-C {integer} : Conservation score cutoff, 4 by default, not used unless -A is set to false (F)\
-N {ratio} : Noise cutoff (minimal proportion of sequences required to be considered at each position). A number between 0 and 1, 0.1 by default\
-A {T or F} : Auto-detect conservation score cutoff, on (T) by default\
-P {ratio} : Minimal conserved proportion of the alignment (until a lower conservation cutoff is considered), 0.6 by default\
-L {integer} : Look-ahead length (the number of residues to consider when determining the start and end of conserved regions), 5 by default\
-M {integer} : Minimal conserved region length, 20 by default\
--single_profile {T or F} : Build only one single HMM for the entire alignment from the input sequences, off (F) by default\
--mode {divergent, conserved, hybrid} : Selects the mode in which the profile database is built, default is divergent\
--dereplicate {ratio or F} : Will dereplicate the input data using Usearch before building the database, using the specified idenity threshold, off (F) by default\

--filter_uncultured {T or F} : Will try to filter out sequences that are derived from uncultured species, off (F) by default\
--filter_level {integer} : Will filter out sequences with taxonomic information lower than the specified level, 0 by default\
--correct_taxonomy {T or F} : Will try to correct the taxonomic information at order, family, genus and species level, off (F) by default\
--cutoffs {string} : A string of number defining the cutoffs at different taxonomic levels. Will turn off automatic calculation of cutoffs. If blank, cutoffs are determined automatically, default is blank (off)\
--sample {integer} : The number of sequences to aim to investigate when determining taxonomic cutoffs, 1000 by default\

--evaluate {T or F} : Statistically evaluate the performance of the database built. This increases the time requirement for the process dramatically, off (F) by default\
--iterations {integer} : Number of iterations for the statistical evaluation, 10 by default\
--test_sets {ratio} : Proportion of sequences to leave out for testing. Several values can be specified, separated by commas, 0.1 by default\
--db {directory} : Skips building the database, and only runs the evaluation on the specified database, not used by default\

-h : displays this help message\
--help : displays this help message\
--bugs : displays the bug fixes and known bugs in this version of Metaxa\
--license : displays licensing information\
";


## Print title message
print STDERR "$app_title\nby $app_author\nVersion: $app_version\n$app_message";
print STDERR "-----------------------------------------------------------------\n";

## Setup default variable values
use List::Util qw(first max maxstr min minstr reduce shuffle sum);

$bindir = $0;
$bindir =~ s/metaxa2_dbb$//;
$input = "";
$inputa = "";
$inputb = "";
$inputc = "";
$inpute = "";
$inputm = "";
$inputn = "";
$inputo = "";
$output = "new_database";
$hmm_dir = "";
$taxfile = "";
$gene = "";
$startRepID = "";
$auto_rep = 1;
$full_length = 100;
$cpu = 1;
$C = 4;	     ## Conservation score cutoff (4 by default, but not used)
$N = 0.1;    ## Noise cutoff (0.01 by default)
$A = 1;	     ## Auto-detect conservation score cutoff (1 by default)
$P = 0.6;    ## Minimal conserved proportion (0.6 by default)
$L = 5;	     ## Look-ahead length (5 by default)
$M = 20;     ## Minimal conserved region length (20 by default)
$single_profile = 0;
$mode = "divergent";
$filter_uncult = 0;
$filter_level = 0;
$correct_taxonomy = 0;
$sample_aim = 1000;
$save_raw = 1;
$blast_plus = 0;
$evaluate = 0;
$dereplicate = -1;
$evalDB = "";
$iterations = 10;
@test_sets[0] = 0.1;
$cutoffs = "";
$list_of_phyla = "Acanthocephala
Acoelomorpha
Annelida
Arthropoda
Brachiopoda
Bryozoa
Chaetognatha
Chordata
Cnidaria
Ctenophora
Cycliophora
Echinodermata
Entoprocta
Gastrotricha
Gnathostomulida
Hemichordata
Kinorhyncha
Loricifera
Micrognathozoa
Mollusca
Nematoda
Nematomorpha
Nemertea
Onychophora
Orthonectida
Phoronida
Placozoa
Platyhelminthes
Porifera
Priapulida
Rhombozoa
Rotifera
Sipuncula
Tardigrada
Xenacoelomorpha
Bilateria
Anthocerotophyta
Bryophyta
Marchantiophyta
Hepatophyta
Lycopodiophyta
Lycophyta
Pteridophyta
Pinophyta
Coniferophyta
Cycadophyta
Ginkgophyta
Gnetophyta
Magnoliophyta
Chytridiomycota
Blastocladiomycota
Zygomycota
Glomeromycota
Ascomycota
Basidiomycota
Microsporidia
Neocallimastigomycota
Actinopoda
Foraminifera
Euglenophyta
Chrysophyta
Rhodophyta
Phaeophyta
Ciliophora
Acrasiomycota
Myxomycota
Rhizopoda
Dinoflagellata
Sarcomastigophora
Apicomplexa
Oomycota
Crenarchaeota
Euryarchaeota
Korarchaeota
Nanoarchaeota
Thaumarchaeota
Rozellomycota
Acidobacteria
Actinobacteria
Aquificae
Armatimonadetes
Bacteroidetes
Caldiserica
Chlamydiae
Chlorobi
Chloroflexi
Chrysiogenetes
Cyanobacteria
Deferribacteres
Deinococcus-Thermus
Dictyoglomi
Elusimicrobia
Fibrobacteres
Firmicutes
Fusobacteria
Gemmatimonadetes
Lentisphaerae
Nitrospira
Planctomycetes
Proteobacteria
Spirochaetes
Synergistetes
Tenericutes
Thermodesulfobacteria
Thermomicrobia
Thermotogae
Verrucomicrobia
Candidate phylum
Chlorophyta
Charophyta
Radiata
Parazoa
Arthrophyta
Streptophyta 
Glaucophyta
Rhodophyta 
Mitochondria
Chloroplast";
@list_of_phyla = split('\n', $list_of_phyla);

## Read command-line options
for ($i = 0; $i <= scalar(@ARGV); $i++) { # Goes through the list of arguments
  $arg = @ARGV[$i];		# Stores the current argument in $arg

  if ($arg eq "-i") {		# Read input files from -i flag
    $i++;
    $input = @ARGV[$i];
  }
  if ($arg eq "-o") {		# Read output directory from -o flag
    $i++;
    $output = @ARGV[$i];
  }
  if ($arg eq "-t") {		# Read tax file from -t flag
    $i++;
    $taxfile = @ARGV[$i];
  }
  if ($arg eq "-p") {		# Read hmmdir file from -p flag
    $i++;
    $hmmdir = @ARGV[$i];
  }

  if ($arg eq "-a") {	      # Read archaeal input files from -a flag
    $i++;
    $inputa = @ARGV[$i];
  }
  if ($arg eq "-b") {	     # Read bacterial input files from -b flag
    $i++;
    $inputb = @ARGV[$i];
  }
  if ($arg eq "-c") {	   # Read chloroplast input files from -c flag
    $i++;
    $inputc = @ARGV[$i];
  }
  if ($arg eq "-e") {	     # Read eukaryote input files from -e flag
    $i++;
    $inpute = @ARGV[$i];
  }
  if ($arg eq "-m") {	 # Read mitochondrial input files from -m flag
    $i++;
    $inputm = @ARGV[$i];
  }
  if ($arg eq "-n") { # Read metazoan mitochondrial input files from -n flag
    $i++;
    $inputn = @ARGV[$i];
  }
  if ($arg eq "--other") { # Read archaeal input files from --other flag
    $i++;
    $inputo = @ARGV[$i];
  }

  if (($arg eq "-g") || ($arg eq "--gene")) { # Read gene from -g (or --gene) flag
    $i++;
    $gene = @ARGV[$i];
  }
  if (($arg eq "-r") || ($arg eq "--rep")) { # Read representative ID from -r (or --rep) flag
    $i++;
    $startRepID = @ARGV[$i];
  }
  if ($arg eq "--cpu") {	# Read the CPU count
    $i++;
    $cpu = @ARGV[$i];
  }

  if (($arg eq "-C") || ($arg eq "--conservation_score")) {
    $i++;
    $C = @ARGV[$i];
  }
  if (($arg eq "-P") || ($arg eq "--conservation")) {
    $i++;
    $P = @ARGV[$i];
  }
  if (($arg eq "-N") || ($arg eq "--noise_cutoff")) {
    $i++;
    $N = @ARGV[$i];
  }
  if (($arg eq "-L") || ($arg eq "--lookahead")) {
    $i++;
    $L = @ARGV[$i];
  }
  if (($arg eq "-M") || ($arg eq "--region_length")) {
    $i++;
    $M = @ARGV[$i];
  }
  if (($arg eq "-A") || ($arg eq "--auto")) {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $A = 0;
    } else {
      $A = 1;
    }
  }
  if ($arg eq "--plus") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $blast_plus = 0;
    } else {
      $blast_plus = 1;
    }
  }
  if ($arg eq "--single_profile") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $single_profile = 0;
    } else {
      $single_profile = 1;
    }
  }

  if ($arg eq "--filter_uncultured") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $filter_uncult = 0;
    } else {
      $filter_uncult = 1;
    }
  }
  if ($arg eq "--filter_level") { # Read tax filter level
    $i++;
    $filter_level = @ARGV[$i];
  }
  if ($arg eq "--correct_taxonomy") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $correct_taxonomy = 0;
    } else {
      $correct_taxonomy = 1;
    }
  }
  if ($arg eq "--sample") {	# Read sample aim number
    $i++;
    $sample_aim = @ARGV[$i];
  }

  if ($arg eq "--full_length") { # Read full length definition
    $i++;
    $full_length = @ARGV[$i];
  }

  if ($arg eq "--mode") {	# Which mode to use?
    $i++;
    $mode = lc(substr(@ARGV[$i],0,1));
    if ($mode eq "h") {
      $mode = "hybrid";
    }
    if ($mode eq "c") {
      $mode = "conserved";
    }
    if ($mode eq "d") {
      $mode = "divergent";
    }
  }

  if ($arg eq "--save_raw") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $save_raw = 0;
    } else {
      $save_raw = 1;
    }
  }

  if ($arg eq "--auto_rep") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $auto_rep = 0;
    } else {
      $auto_rep = 1;
    }
  }

  if ($arg eq "--dereplicate") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[0-9.]*$/) { # Check if argument is only numeric (incl period)
      $dereplicate = @ARGV[$i];
    } else {
      $dereplicate = -1;
    }
  }

  if ($arg eq "--cutoffs") {	# Read cutoffs
    $i++;
    $cutoffs = @ARGV[$i];
  }

  if ($arg eq "--evaluate") {
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $evaluate = 0;
    } else {
      $evaluate = 1;
    }
  }
  if ($arg eq "--iterations") {	# Read the iterations count for testing
    $i++;
    $iterations = @ARGV[$i];
  }
  if ($arg eq "--test_sets") { # Read the test sets counts for testing
    $i++;
    (@test_sets) = split(',',@ARGV[$i]);
  }
  if ($arg eq "--db") {		# Read the database to evaluate
    $i++;
    $evalDB = @ARGV[$i];
    $evaluate = 1;
  }



  ## If "-h" or "--help" are among the options, output usage data and options
  if (($arg eq "-h") || ($arg eq "--help")) {
    print "Usage: metaxa2_dbb -i <input file> -o <output file>\nOptions:$options";
    print "-----------------------------------------------------------------\n";
    exit;			# Exit Metaxa
  }

  ## If "--bugs" is among the options, output bugs and features information
  if ($arg eq "--bugs") {
    print "$bugs\n";
    exit;			# Exit Metaxa
  }

  ## If "--license" is among the options, output license information
  if ($arg eq "--license") {
    print "$license\n";
    exit;			# Exit Metaxa
  }

  if ($arg eq "--debug") {	# Run Metaxa in debug mode
    $debug = 1;
  }
  if ($arg eq "--pipeline") {   # Run Metaxa in pipeline mode
    $pipeline = 1;
  }
}

## Setup some variables dependent on input

$gene = uc($gene);


## Check for binaries

chomp($path = `which hmmpress`); # Get the path for hmmpress
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate HMMER binaries! It seems that hmmpress is not installed properly.\
Consult the manual for installation instructions. Note that HMMER3 is required. Previous HMMER-versions will not work.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

chomp($path = `which hmmbuild`); # Get the path for hmmbuild
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate HMMER binaries! It seems that hmmbuild is not installed properly.\
Consult the manual for installation instructions. Note that HMMER3 is required. Previous HMMER-versions will not work.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

chomp($path = `which mafft`);   # Get the path for mafft
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate MAFFT binaries! It seems that mafft is not installed properly.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

if ($blast_plus == 0) {
  chomp($path = `which formatdb`); # Get the path for formatdb
  if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
    print STDERR "FATAL ERROR :: Could not locate BLAST binaries! It seems that formatdb is not installed properly.\
Consult the manual for installation instructions. To use BLAST+ instead of legacy BLAST, run metaxa2_dbb with the\
'--plus T' option.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }
} else {
  chomp($path = `which makeblastdb`); # Get the path for makeblastdb
  if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
    print STDERR "FATAL ERROR :: Could not locate BLAST+ binaries! It seems that makeblastdb is not installed properly.\
Consult the manual for installation instructions. To use legacy BLAST instead of BLAST+, run metaxa2_dbb with the\
'--plus F' option.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }
}
  
chomp($path = `which metaxa2`); # Get the path for metaxa2
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate Metaxa2 binaries! It seems that Metaxa2 is not installed properly.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

$use_vsearch = 0;
chomp($path = `which usearch`); # Get the path for usearch
if ($path eq "") { # If the path is empty, then check try vsearch instead
  chomp($path = `which vsearch`); # Try to get the path for vsearch
  if ($path eq "") { # If the path is empty, then show an error message
    print STDERR "ERROR :: Could not locate Usearch or Vsearch binary!\
Metaxa2_dbb will continue but with limited functionality.\n";
    print STDERR "-----------------------------------------------------------------\n";
    $use_vsearch = -1;
  } else {
    $use_vsearch = 1;
  }
}


chomp($path = `which metaxa2_x`); # Get the path for metaxa2_x
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate Metaxa2 binaries! It seems that Metaxa2 is not installed properly.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa2_dbb will now abort.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

if ($evalDB eq "") {
  if ($input ne "") {		# If an input file is specified
    chomp($errormsg = `ls $input* 2>&1 1>/dev/null`); # Get the error msg when looking for the input file
    if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
      print STDERR "FATAL ERROR :: The specified input file could not be found.\
Metaxa will now abort.\n";
      print STDERR "-----------------------------------------------------------------\n";
      exit;
    } else {
      push(@inputFiles, $input);
      push(@types, "E");
    }
  } else {
    undef @inputFiles;
    if ($inputa ne "") {
      push(@inputFiles, $inputa);
      push(@types, "A");
    }
    if ($inputb ne "") {
      push(@inputFiles, $inputb);
      push(@types, "B");
    }
    if ($inputc ne "") {
      push(@inputFiles, $inputc);
      push(@types, "C");
    }
    if ($inpute ne "") {
      push(@inputFiles, $inpute);
      push(@types, "E");
    }
    if ($inputm ne "") {
      push(@inputFiles, $inputm);
      push(@types, "M");
    }
    if ($inputn ne "") {
      push(@inputFiles, $inputn);
      push(@types, "N");
    }
    if ($inputo ne "") {
      push(@inputFiles, $inputo);
      push(@types, "O");
    }
    if (scalar(@inputFiles) < 1) {
      print STDERR "FATAL ERROR :: No input file(s) specified (-i option)!\
Metaxa will now abort.\n";
      print STDERR "-----------------------------------------------------------------\n";
      exit;
    }
  }
} else {
  chomp($errormsg = `ls $evalDB/blast.taxonomy.txt 2>&1 1>/dev/null`); # Get the error msg when looking for the input file
  if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
    print STDERR "FATAL ERROR :: The specified database could not be found or is not a valid Metaxa2 datbase!\
Metaxa will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }
  $output = $evalDB;
}

if ($hmmdir ne "") {		# If a HMM directory file is specified
  chomp($errormsg = `ls $hmmdir/*.hmm 2>&1 1>/dev/null`); # Get the error msg when looking for the HMM files
  if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
    print STDERR "FATAL ERROR :: The specified HMM database could not be found or is not valid.\
Metaxa will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }
}

if ($evalDB eq "") {
  if ($taxfile ne "") {		# If an tax file is specified
    chomp($errormsg = `ls $taxfile* 2>&1 1>/dev/null`); # Get the error msg when looking for the input file
    if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
      print STDERR "FATAL ERROR :: The specified taxonomy file could not be found.\
Metaxa will now abort.\n";
      print STDERR "-----------------------------------------------------------------\n";
      exit;
    }
  } else {
    print STDERR "FATAL ERROR :: No taxonomy file specified (-t option)!\
Metaxa will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }
}

`mkdir $output 2> /dev/null`;
$tmp = $output . "/TEMPFILES";
`mkdir $tmp`;

$now = localtime;
if ($silent == 0) {
  print STDERR "$now : Starting Metaxa2 Database Builder...\n";
  print STDERR "-----------------------------------------------------------------\n";
}

if ($evalDB eq "") {
  foreach ($inputFile = 0; $inputFile < scalar(@inputFiles); $inputFile++) {
    $repID = $startRepID;
    $input = @inputFiles[$inputFile];
    $TYPE = @types[$inputFile];
    $type_lc = lc($TYPE);
    $now = localtime;
    if ($silent == 0) {
      print STDERR "$now : Creating sub-database for type $TYPE...\n";
    }

    chomp($errormsg = `ls $input* 2>&1 1>/dev/null`); # Get the error msg when looking for the input file
    if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
      print STDERR "ERROR :: The specified input file for type $TYPE ($input) could not be found.\
Metaxa will skip this type and continue.\n";
      print STDERR "-----------------------------------------------------------------\n";
      next;
    }
  
    if ($dereplicate >= 0) {
      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : Dereplicating input data...\n";
      }
      if ($use_vsearch == 0) {
	`usearch --cluster_fast $input --centroids $input.derep.fasta --id $dereplicate --quiet`;
	$input = "$input.derep.fasta";
      } else {
	if ($use_vsearch == 1) {
	  `vsearch --cluster_fast $input --centroids $input.derep.fasta --id $dereplicate --quiet`;
	$input = "$input.derep.fasta";
	} else {
	  print STDERR "ERROR :: Usearch or Vsearch not found, dereplication not possible.\n";
	}
      }
    }
  
    if ($mode eq "divergent") {
      if ($hmmdir eq "") {
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "$now : Building profile database for gene $gene in divergent mode...\n";
	}
    
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Clustering input sequences...\n";
	}
	`mkdir $tmp/$TYPE.clusters/`;

	if ($use_vsearch == 0) {
	  `usearch --cluster_fast $input --clusters $tmp/$TYPE.clusters/cluster_ --id 0.2 --uc $tmp/$TYPE.divergent.usearch.uc --quiet`;
	} else {
	  if ($use_vsearch == 1) {
	    `vsearch --cluster_fast $input --clusters $tmp/$TYPE.clusters/cluster_ --id 0.2 --uc $tmp/$TYPE.divergent.usearch.uc --quiet`;
	  } else {
	    print STDERR "FATAL ERROR :: Usearch or Vsearch not found. Clustering not possible, try conserved mode instead.\n";
	    exit;
	  }
	}
    
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Aligning clusters...\n";
	}
	@clusterfiles = `ls $tmp/$TYPE.clusters/cluster_*`;
	foreach $clusterfile (@clusterfiles) {
	  chomp($clusterfile);
	  `mafft --auto --reorder --quiet --thread $cpu $clusterfile > $clusterfile.afa`;
	  $resulting_nseq = `grep -c ">" $clusterfile.afa`;  
	  if ($resulting_nseq == 0) {
	    `cp $clusterfile $clusterfile.afa`;
	  }
	}

	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Splitting alignments...\n";
	}
	@clusterfiles = `ls $tmp/$TYPE.clusters/cluster_*.afa`;
	foreach $clusterfile (@clusterfiles) {
	  chomp($clusterfile);
	  open (CLUSTER, $clusterfile);
	  open (START, ">$clusterfile.start");
	  open (STOP, ">$clusterfile.end");
	  $seq = "";
	  while ($line = <CLUSTER>) {
	    chomp($line);
	    if (substr($line, 0, 1) eq ">") {
	      if ($seq ne "") {
		$mid = int(length($seq) / 2);
		print START substr($seq, 0, $mid) . "\n";
		print STOP substr($seq, $mid) . "\n";
	      }
	      print START ">start_" . substr($line, 1) . "\n";
	      print STOP ">end_" . substr($line, 1) . "\n";
	      $seq = "";
	    } else {
	      $seq = $seq . $line;
	    }
	  }
	  if ($seq ne "") {
	    $mid = int(length($seq) / 2);
	    print START substr($seq, 0, $mid) . "\n";
	    print STOP substr($seq, $mid) . "\n";
	  }
	}
	close CLUSTER;
	close START;
	close STOP;


	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Building models for each cluster...\n";
	}
	`mkdir $output/HMMs`;
	@clusterfiles = `ls $tmp/$TYPE.clusters/cluster_*.afa.start`;
	$no = 0;
	$pname = $TYPE . "1";
	foreach $clusterfile (@clusterfiles) {
	  $no++;
	  $cno = $TYPE . "s". $no;
	  chomp($clusterfile);
	  ## hmmbuild (from afa)
	  `hmmbuild --dna -n $pname --informat afa $tmp/$cno.hmm $clusterfile`;
	  `cat $tmp/$cno.hmm >> $output/HMMs/$TYPE.hmm`;
	}

	@clusterfiles = `ls $tmp/$TYPE.clusters/cluster_*.afa.end`;
	$no = 0;
	$pname = $TYPE . "2";
	foreach $clusterfile (@clusterfiles) {
	  $no++;
	  $cno = $TYPE . "e". $no;
	  chomp($clusterfile);
	  ## hmmbuild (from afa)
	  `hmmbuild --dna -n $pname --informat afa $tmp/$cno.hmm $clusterfile`;
	  `cat $tmp/$cno.hmm >> $output/HMMs/$TYPE.hmm`;
	}
    
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Finishing models...\n";
	}
	`hmmpress $output/HMMs/$TYPE.hmm`;
    
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Saving models file...\n";
	}
	## Save the file containing the model names
    
	open (NAMES, ">>$output/HMMs/hmm_names.txt");
	print NAMES $TYPE . "1\t" . $TYPE . "1\tstart\n";
	print NAMES $TYPE . "2\t" . $TYPE . "2\tend\n";
	close NAMES;
      } else {
	if ($silent == 0) {
	  print STDERR "$now : Copying and rebuilding profiles...\n";
	}
	`mkdir $output/HMMs`;
	`cp $hmmdir/$TYPE.hmm $output/HMMs/$TYPE.hmm`;
	`hmmpress $output/HMMs/$TYPE.hmm`;
	`cp $hmmdir/hmm_names.txt $output/HMMs/hmm_names.txt`;
      }
      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : Preparing classification database...\n";
      }

      $rno = 2;

      $metaxa2_x_N = int($rno / 2);

      $now = localtime;
      if ($silent == 0) {
	print STDERR "     $now : Running metaxa2_x to extract sequences matching $metaxa2_x_N conserved domains...\n";
      }
    
      ## Run Metaxa2_x with -N X option to extract sequences containing most conserved domains
    
      `metaxa2_x -i $input -o $tmp/$TYPE.full-length-matching-models -p $output/HMMs/ --cpu $cpu -t $type_lc -N $metaxa2_x_N --allow_single_domain F 2>> $tmp/metaxa2_x_log.txt`;
      `mv $tmp/$TYPE.full-length-matching-models.extraction.fasta $tmp/$TYPE.full-length-matching-models.fasta`;
    
      $now = localtime;
      if ($silent == 0) {
	print STDERR "     $now : Reformatting sequences...\n";
      }
    
      ## Remove "|O|O" from identifiers
    
      ## Add ".X"
    
      $saveSeq = 0;
      $seq = "";
      $id = "";
      open (INPUT, "$tmp/$TYPE.full-length-matching-models.fasta");
      open (OUTPUT, ">$tmp/$TYPE.fasta");
      open (TAXIDDUMP, ">$tmp/$TYPE.id_dump.txt");
      while ($line = <INPUT>) {
	chomp($line);
	if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
	  if (eof(INPUT)) {
	    $seq = $seq . $line;
	  }
	  if ($id ne "") {
	    $orgid = substr($id, 0, length($id) - 2);
	    $id = substr($id, 0, length($id) - 2);
	    $id =~ s/[^A-Za-z0-9._]/_/g;
	    $id = substr($id, 1, 60);

	    print TAXIDDUMP $id . "\n";

	    $ID_to_TYPE{$id} = $TYPE;
	    if ($orgid =~ m/\|/) {
	      $acc = $id;
	      @orgid_parts = split('\|', $orgid);
	      foreach $part (@orgid_parts) {
		if ($part =~ m/[A-Z]+[0-9_]+\.[0-9]+/) {
		  $acc = $part;
		  $acc =~ s/[^A-Za-z0-9._]/_/g;
		  $acc =~ s/\.[0-9]+//;
		}
	      }
	      $ACC_to_ID{$acc} = $id;
	    } else {
	      $ACC_to_ID{$id} = $id;
	    }
	    $id = $id . "." . $TYPE;
	  
	    print OUTPUT ">" . $id . "\n";
	    print OUTPUT uc($seq) . "\n";
	  }
	  ($id) = split(' ', $line);
	  $seq = "";
	} else {
	  $seq = $seq . $line;
	} 
      }
      close INPUT;
      close OUTPUT;
      close TAXIDDUMP;
    
      `cat $tmp/$TYPE.fasta >> $tmp/preblast.fasta`;
    
      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : End of processing for type $TYPE.\n";
	print STDERR "-----------------------------------------------------------------\n";
      }
    }
    if (($mode eq "conserved") || ($mode eq "hybrid")) { ## This is conserved or hybrid mode
      if ($hmmdir eq "") {
	$smallest_rno = 100;
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "$now : Building profile database for gene $gene in $mode mode...\n";
	}
    
	if ($mode eq "hybrid") {
	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "     $now : Clustering input sequences...\n";
	  }
	  `mkdir $tmp/$TYPE.clusters/`;

	  if ($use_vsearch == 0) {
	    `usearch --cluster_fast $input --clusters $tmp/$TYPE.clusters/cluster_ --id 0.2 --uc $tmp/$TYPE.divergent.usearch.uc --quiet`;
	  } else {
	    if ($use_vsearch == 1) {
	      `vsearch --cluster_fast $input --clusters $tmp/$TYPE.clusters/cluster_ --id 0.2 --uc $tmp/$TYPE.divergent.usearch.uc --quiet`;
	    } else {
	      print STDERR "FATAL ERROR :: Usearch or Vsearch not found. Clustering not possible, try conserved mode instead.\n";
	      exit;
	    }
	  }
	} else {
	  `mkdir $tmp/$TYPE.clusters`;
	  `cp $input $tmp/$TYPE.clusters/cluster_0`;
	}
	@clusterfiles = `ls $tmp/$TYPE.clusters/cluster_*`;
	$clusterNo = 0;
	foreach $clusterfile (@clusterfiles) {
	  chomp($clusterfile);
	  $clusterNo++;
	  if (scalar(@clusterfiles) > 1) {
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "$now : Building models for cluster $clusterNo...\n";
	    }
	  }
	  if ($auto_rep == 1) {
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "$now : Identifying representative sequence...\n";
	    }
      
	    if ($use_vsearch == 0) {
	      `usearch --cluster_fast $clusterfile --centroids $clusterfile.$TYPE.rep.usearch.fasta --id 0.8 --uc $clusterfile.$TYPE.rep.usearch.uc --quiet`;
	    } else {
	      if ($use_vsearch == 1) {
		`vsearch --cluster_fast $clusterfile --centroids $clusterfile.$TYPE.rep.usearch.fasta --id 0.8 --uc $clusterfile.$TYPE.rep.usearch.uc --quiet`;
	      } else {
		print STDERR "ERROR :: Could not locate the Usearch binary! Make sure it is named 'usearch'.\
Metaxa will not be able to automatically determine a representative sequence (the first in the file will be used).\n";
		print STDERR "-----------------------------------------------------------------\n";
	      }
	    }
	    if ($use_vsearch != -1) {
	      open (UC, "$clusterfile.$TYPE.rep.usearch.uc");
	      $biggest_cluster = "";
	      $biggest_size = 0;
	      while ($line = <UC>) {
		if (substr($line, 0, 1) eq "C") {
		  ($cluster_type, $cluster_no, $cluster_size, $clusterx, $clustery, $clusterz, $clusterq, $clusterw, $cluster_ID) = split('\t', $line);
		  if ($cluster_size > $biggest_size) {
		    $biggest_cluster = $cluster_ID;
		    $biggest_size = $cluster_size;
		  }
		}
	      }
	      close UC;
	      if ($biggest_cluster ne "") {
		$repID = $biggest_cluster;
		$now = localtime;
		if ($silent == 0) {
		  print STDERR "     $now : Using $biggest_cluster as representative sequence...\n";
		}
	      }
	    }
	  }
	
	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "$now : Extracting full-length sequences from input file...\n";
	    print STDERR "     $now : Extracting representative sequence...\n";
	  }
	  
	  ## Get $repID sequence from input file
	  $saveSeq = 0;
	  $repSeq = "";
	  $seq = "";
	  open (INPUT, $clusterfile);
	  while ($line = <INPUT>) {
	    chomp($line);
	    if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
	      if (substr($line, 0, 1) ne ">") {
		$seq = $seq . $line;
	      }
	      if ($saveSeq == 1) {
		$repSeq = $seq;
		last;
	      } 
	      ($id) = split(' ', $line);
	      if (($id eq ">$repID") || ($repID eq "")) {
		$repID = substr($id, 1);
		$saveSeq = 1;
	      }
	      $seq = "";
	    } else {
	      $seq = $seq . $line;
	    } 
	  }
	  close INPUT;

	  $repSeq = uc($repSeq);
	  $repSeq =~ s/[^A-Z]//g;
	  
	  if ($full_length > 0) {
	    open (START, ">$clusterfile.$TYPE.repstart.fasta");
	    print START ">$repID.start\n";
	    print START substr($repSeq, 0, $full_length);
	    print START "\n";
	    close START;
    
	    open (STOP, ">$clusterfile.$TYPE.repend.fasta");
	    print STOP ">$repID.end\n";
	    print STOP substr($repSeq, -$full_length);
	    print STOP "\n";
	    close STOP;
	    
    
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "     $now : Building models for sequence start and end...\n";
	    }
    
	    ## Build models for first and last $full_length bp of representative sequence
    
	    `mkdir $clusterfile.HMMs`;
	    `hmmbuild -n X01 --dna --informat afa $clusterfile.HMMs/$TYPE.REPSTART.hmm $clusterfile.$TYPE.repstart.fasta`;
	    `hmmbuild -n X02 --dna --informat afa $clusterfile.HMMs/$TYPE.REPEND.hmm $clusterfile.$TYPE.repend.fasta`;
	    `cat $clusterfile.HMMs/$TYPE.REPSTART.hmm $clusterfile.HMMs/$TYPE.REPEND.hmm > $clusterfile.HMMs/$TYPE.hmm`;
	    `hmmpress $clusterfile.HMMs/$TYPE.hmm`;
    
	    open (NAMES, ">$clusterfile.HMMs/hmm_names.txt");
	    print NAMES "X01\tStart_$gene\tstart\n";
	    print NAMES "X02\tEnd_$gene\tend";
	    close NAMES;
    
	    chomp($alphabet = `grep 'ALPH' $clusterfile.HMMs/$TYPE.hmm | sort | uniq -c | sort -rn | sed "s/.* //"`);
    
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "     $now : Extracting full-length sequences from input file using metaxa2_x...\n";
	    }
    
	    ## Run metaxa2_x using the representative sequence models as profile database
	    
	    `metaxa2_x -i $clusterfile -o $clusterfile.$TYPE.REPMODELS -p $clusterfile.HMMs/ --cpu $cpu -t $type_lc -N 2 --allow_single_domain F 2>> $tmp/metaxa2_x_log.txt`;
	    `mv $clusterfile.$TYPE.REPMODELS.extraction.fasta $clusterfile.$TYPE.full-length.fasta`;
	  } else {
	    `cp $clusterfile $clusterfile.$TYPE.full-length.fasta`;
	  }

	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "$now : Aligning full-length sequences...\n";
	    print STDERR "     $now : Aligning...\n";
	  }

	  ## Run MAFFT

	  `mafft --auto --reorder --quiet --thread $cpu $clusterfile.$TYPE.full-length.fasta > $clusterfile.$TYPE.full-length.afa`;
	  $resulting_nseq = `grep -c ">" $clusterfile.$TYPE.full-length.afa`;  
	  if ($resulting_nseq == 0) {
	    `cp $clusterfile.$TYPE.full-length.fasta $clusterfile.$TYPE.full-length.afa`;
	  }

	  if ($full_length > 0) {
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "     $now : Trimming...\n";
	    }
    
	    ## Trim regions outside the start and end profiles
	    
	    ## Find reference sequence in alignment
    
	    $saveSeq = 0;
	    $repSeq = "";
	    $seq = "";
	    open (INPUT, "$clusterfile.$TYPE.full-length.afa");
	    while ($line = <INPUT>) {
	      chomp($line);
	      if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
		if (substr($line, 0, 1) ne ">") {
		  $seq = $seq . $line;
		}
		if ($saveSeq == 1) {
		  $repSeq = $seq;
		  last;
		} 
		($id) = split(' ', $line);
		if (($id eq ">$repID|$TYPE") || ($repID eq "")) {
		  $repID = substr($id, 1);
		  $saveSeq = 1;
		}
		$seq = "";
	      } else {
		$seq = $seq . $line;
	      } 
	    }
	    close INPUT;
    
	    ## Find position of first non-gap character.
    
	    for ($firstBase = 0; $firstBase < length($repSeq); $firstBase++) {
	      if (substr($repSeq, $firstBase, 1) ne "-") {
		last;
	      }
	    }
    
	    ## Find position of last non-gap character.
	    
	    for ($lastBase = length($repSeq) - 1; $lastBase >= 0 ; $lastBase--) {
	      if (substr($repSeq, $lastBase, 1) ne "-") {
		last;
	      }
	    }
    
	    $baseLen = $lastBase - $firstBase + 1;
    
	    ## Remove all characters outside these from the alignment for ALL sequences
    
	    $saveSeq = 0;
	    $repSeq = "";
	    $seq = "";
	    $id = "";
	    open (INPUT, "$clusterfile.$TYPE.full-length.afa");
	    open (OUTPUT, ">$clusterfile.$TYPE.full-length-trimmed.afa");
	    while ($line = <INPUT>) {
	      chomp($line);
	      if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
		if (substr($line, 0, 1) ne ">") {
		  $seq = $seq . $line;
		}
		if ($id ne "") {
		  print OUTPUT $id . "\n";
		  print OUTPUT substr($seq, $firstBase, $baseLen) . "\n";
		}
		($id) = split(' ', $line);
		$seq = "";
	      } else {
		$seq = $seq . $line;
	      } 
	    }
	    close INPUT;
	    close OUTPUT;    
	  } else {
	    `cp $clusterfile.$TYPE.full-length.afa $clusterfile.$TYPE.full-length-trimmed.afa`;
	  }

	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "     $now : Re-aligning...\n";
	  }

	  ## Run MAFFT again on trimmed sequences

	  `mafft --auto --reorder --quiet --thread $cpu $clusterfile.$TYPE.full-length-trimmed.afa > $clusterfile.$TYPE.full-length-trimmed-realigned.afa`;

	  $resulting_nseq = `grep -c ">" $clusterfile.$TYPE.full-length-trimmed-realigned.afa`;  
	  if ($resulting_nseq == 0) {
	    `cp $clusterfile.$TYPE.full-length-trimmed.afa $clusterfile.$TYPE.full-length-trimmed-realigned.afa`;
	  }

	  if ($single_profile == 0) {
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "$now : Determining conserved regions...\n";
	    }

	    ## This needs to be a custom algorithm similar to that of FAAAAT

	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "     $now : Reading alignment...\n";
	    }

	    $seqCount = 0;
	    undef @ids;
	    open (ALN, "$clusterfile.$TYPE.full-length-trimmed-realigned.afa");
	    while ($line = <ALN>) {
	      chomp($line);
	      if ((substr($line, 0, 1) eq ">") || (eof(ALN))) {
		if (substr($line, 0, 1) ne ">") {
		  $seq = $seq . $line;
		}
		if ($seq ne "") {
		  $seq = uc($seq);
		  $seqs{$id} = $seq;
		  $len = length($seq);
		  $seqCount++;
		}
		($id) = split(' ', $line);
		if (substr($id, 0 , 1) eq ">") {
		  $id = substr($id, 1);
		  $header = $line;
		  $sc = 1;
		  while (defined($headers{$id})) {
		    $sc++;
		    $id =~ s/_$sc$//;
		    $id = $id . "_$sc";
		  }
		  $headers{$id} = $line;
		  push(@ids, $id);
		}
		$seq = "";
	      } else {
		$seq = $seq . $line;
	      }
	    }
	    close ALN;

	    @reslist = ("G","A","C","T","-","N");
	    if ($alphabet eq "DNA") {
	      @reslist = ("G","A","C","T","-","N");
	    }
	    if ($alphabet eq "RNA") {
	      @reslist = ("G","A","C","U","-","N");
	    }
	    if ($alphabet eq "amino") {
	      @reslist = ("G","P","A","V","L","I","M","C","F","Y","W","H","K","R","Q","N","E","D","S","T","-","X");
	    }

	    if ($A == 1) {
	      $C = scalar(@reslist);
	    }

	    $conservedAAs = 0;
	    $conservedProp = 0;

	    $pass = 0;
	    while ($conservedProp <= $P) {
	      $pass++;
	      $now = localtime;
	      if ($silent == 0) {
		print STDERR "     $now : Scanning alignment, pass $pass...\n";
	      }

	      undef @conscores;
	      undef @consres;
	      undef @consensusres;
	      $consensus = "";
	      $conresstring = "";

	      for ($res = 0; $res < $len; $res++) {
		## Reset distribution data
		foreach $aa (@reslist) {
		  $distr{$res.$aa} = 0;
		}
    
		## Create distribution
		foreach $id (@ids) {
		  $aa = substr($seqs{$id}, $res, 1);
		  if (defined($distr{$res.$aa})) {
		    $distr{$res.$aa} = $distr{$res.$aa} + 1;
		  } else {
		    $distr{$res.$aa} = 1;
		  }
		}
    
		## Sort distribution
		undef @nonsorted;
		undef @sorted;

		foreach $aa (@reslist) {
		  push(@nonsorted, $distr{$res.$aa} . " " . $aa);
		}
		@sorted = sort {$b <=> $a} @nonsorted;
		($bestCount,$bestAA) = split(' ', @sorted[0]);
		push(@bestseq, $bestAA);
		push(@bestprop, $bestCount / $seqCount);
    
		## Calculate conservation score
		$score = scalar(@reslist);
		foreach $entry (@sorted) {
		  #print $entry . " ,  ";
		  ($count, $aa) = split(' ', $entry);
		  if ($count > $seqCount * $N) {
		    $score--;
		  }
		}
		@conscores[$res] = $score;
		if ($debug == 1) {
		  print STDERR $res . "\t: " . $bestAA . "\t";
		}
		if (($bestAA eq "-") || ($bestAA eq "X") || ($bestAA eq "N")) {
		  @conscores[$res] = 0;
		  if ($debug == 1) {
		    print STDERR "-" . "\n";
		  }
		} else {
		  $consensus = $consensus . $bestAA;
		  push(@consensusres, $res);
		  if ($score >= $C) {
		    if ($reverse_mode == 0) {
		      push(@consres, $res);
		      $conresstring = $conresstring . "*";
		      if ($debug == 1) {
			print STDERR "*" . "\n";
		      }
		    } else {
		      $conresstring = $conresstring . " ";
		    }	  
		  } else {
		    if ($reverse_mode == 0) {
		      $conresstring = $conresstring . " ";
		      if ($debug == 1) {
			print STDERR " " . "\n";
		      }
		    } else {
		      push(@consres, $res);
		      $conresstring = $conresstring . "*";
		    }
		  }
		}
		#print $score . "\n";
	      }

	      $conservedAAs = scalar(@consres);
	      $len_nongap = length($consensus);
	      if ($len_nongap > 0) {
		$conservedProp = $conservedAAs / $len_nongap;
	      } else {
		$conservedProp = 0;
	      }
	      print STDERR "         Conserved proportion: $conservedAAs / $len_nongap => $conservedProp \n";
	      $no_conserved_regions = 0;

	      if ($A == 0) {
		last;
	      } else {
		$C--;
	      }
    
	      if ($C < 0) {
		#print STDERR "FATAL ERROR :: No conserved regions could be identified.\
		#Try lowering the conservation proportion cutoff (-P option), now set to $P.
		#Metaxa will now abort.\n";
		#print STDERR "-----------------------------------------------------------------\n";
		#	exit;
		print STDERR "ERROR :: No conserved regions could be identified.\
You may want to try lowering the conservation proportion cutoff (-P option), now set to $P.
Alternatively, your input sequences may be too divergent. If this could be the case, please try the '--divergent T' option.\
Metaxa will continue, but use the entire alignment for a single HMM.\
Note that this may introduce noise to analyses.\n";
		print STDERR "-----------------------------------------------------------------\n";
		$no_conserved_regions = 1;
		last;
	      }

	    }
	  } else {
	    $no_conserved_regions = 1;
	  }

	  if ($no_conserved_regions == 0) {
	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "     $now : Finding conserved regions...\n";
	    }
	    undef @consregions;

	    ## Get conservation scores

	    $consRegion = 0;
	    $rno = 0;

	    open (SCORES, ">$clusterfile.$TYPE.conservation_scores.txt");

	    for ($res = 0; $res < $len; $res++) {
	      $score = @conscores[$res];
	      $extractRegion = 0;
	      $localGaps = 0;
	      for ($lookAhead = 0; $lookAhead <= $L; $lookAhead++) {
		if (@bestseq[$res+$lookAhead+$localGaps] eq "-") {
		  $localGaps++;
		  $lookAhead--;
		} else {
		  if (@conscores[$res+$lookAhead+$localGaps] >= $C) {
		    $extractRegion++;
		  }
		}
	      }
	      if (($extractRegion / $L) > $P) {
		if ($consRegion == 0) {
		  if ($score >= $C) {
		    $regionStart = $res;
		    $consRegion = 1;
		  }
		}
	      } else {
		if ($consRegion == 1) {
		  $regionEnd = $res;
		  if (($regionEnd - $regionStart + 1) >= $M) {
		    $rno++;
		    push(@consregions, "$TYPE$rno : $regionStart - $regionEnd");
		  }
		}
		$consRegion = 0;
	      }
	      if ($consRegion == 1) {
		print SCORES $res . "\t" . $score . "\t" . @bestseq[$res] . "\t" . @bestprop[$res] . "\t" . "+" . "\n";
	      } else {
		print SCORES $res . "\t" . $score . "\t" . @bestseq[$res] . "\t" . @bestprop[$res] . "\t" . " " . "\n";
	      }
	    }
	    close SCORES;

	    $now = localtime;
	    if ($silent == 0) {
	      print STDERR "     $now : $rno conserved regions found.\n";
	    }

	    if ($debug == 1) {
	      foreach $region (@consregions) {
		print STDERR $region . "\n";
	      }
	    }

	  } else {
	    ## Pretending that entire alignment is a conserved region
	    undef @consregions;
	    $rno = 1;
	    push(@consregions, $TYPE . "1 : 1 - $len");
	  }

	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "     $now : Extracting conserved regions from alignment...\n";
	  }

	  ## Cut out the right parts of the alignments and save to separate alignment files

	  for ($region = 0; $region < $rno; $region++) {
	    $saveSeq = 0;
	    $seq = "";
	    $id = "";
	    $regionData = @consregions[$region];
	    ($cno,$rest) = split(' : ', $regionData);
	    ($firstBase,$lastBase) = split(' - ', $rest);
	    $baseLen = $lastBase - $firstBase + 1;
	    open (INPUT, "$clusterfile.$TYPE.full-length-trimmed-realigned.afa");
	    open (OUTPUT, ">$clusterfile.$TYPE.conserved_region_$cno.afa");
	    while ($line = <INPUT>) {
	      chomp($line);
	      if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
		if (substr($line, 0, 1) ne ">") {
		  $seq = $seq . $line;
		}
		if ($id ne "") {
		  print OUTPUT $id . "\n";
		  print OUTPUT substr($seq, $firstBase, $baseLen) . "\n";
		}
		($id) = split(' ', $line);
		$seq = "";
	      } else {
		$seq = $seq . $line;
	      } 
	    }
	    close INPUT;
	    close OUTPUT;
	  }

	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "$now : Building models for conserved regions...\n";
	  }

	  `mkdir $output/HMMs 2> /dev/null`;

	  ## Re-align the separated alignment files using MAFFT

	  for ($region = 0; $region < $rno; $region++) {
	    $regionData = @consregions[$region];
	    ($cno,$rest) = split(' : ', $regionData);
	    $now = localtime;
	    if ($debug == 1) {
	      print STDERR "     $now : Re-aligning conserved region $cno...\n";
	    }

	    `mafft --auto --reorder --quiet --thread $cpu $clusterfile.$TYPE.conserved_region_$cno.afa > $clusterfile.$TYPE.conserved_region_$cno.realigned.afa`;
	    $resulting_nseq = `grep -c ">" $clusterfile.$TYPE.conserved_region_$cno.realigned.afa`;  
	    if ($resulting_nseq == 0) {
	      `cp $clusterfile.$TYPE.conserved_region_$cno.afa $clusterfile.$TYPE.conserved_region_$cno.realigned.afa`;
	    }

	    $now = localtime;
	    if ($debug == 1) {
	      print STDERR "     $now : Building models for conserved region $cno...\n";
	    }
	    ## hmmbuild (from afa)
	    `hmmbuild --dna -n $cno --informat afa $clusterfile.$cno.hmm $clusterfile.$TYPE.conserved_region_$cno.realigned.afa`;
	    `cat $clusterfile.$cno.hmm >> $output/HMMs/$TYPE.hmm`;
	  }


	  $now = localtime;
	  if ($silent == 0) {
	    print STDERR "     $now : Saving models file...\n";
	  }
	  ## Save the file containing the model names

	  if ($rno < $smallest_rno) {
	    $smallest_rno = $rno;
	  }
	  open (NAMES, ">>$output/HMMs/hmm_names.txt");
	  for ($region = 0; $region < $rno; $region++) {
	    $regionData = @consregions[$region];
	    ($cno,$rest) = split(' : ', $regionData);
	    if ($region == 0) {
	      print NAMES "$cno\t$cno\tstart\n";
	    } else {
	      if ($region == $rno - 1) {
		print NAMES "$cno\t$cno\tend\n";   
	      } else {
		print NAMES "$cno\t$cno\n";
	      }
	    }
	  }    
	  close NAMES;
	}
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Finishing models...\n";
	}
	`hmmpress $output/HMMs/$TYPE.hmm`;
      } else {
	if ($silent == 0) {
	  print STDERR "$now : Copying and rebuilding profiles...\n";
	}
	`mkdir $output/HMMs`;
	`cp $hmmdir/$TYPE.hmm $output/HMMs/$TYPE.hmm`;
	`hmmpress $output/HMMs/$TYPE.hmm`;
	`cp $hmmdir/hmm_names.txt $output/HMMs/hmm_names.txt`;
	$smallest_rno = `grep "NAME" $output/HMMs/$TYPE.hmm | sed "s/NAME *//" | cut -c 1-3 | sort | uniq | wc -l | sed "s/[^0-9]//g"`;
      }
  

      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : Preparing classification database...\n";
      }


      $metaxa2_x_N = int($smallest_rno / 2) + 1;

      $now = localtime;
      if ($silent == 0) {
	print STDERR "     $now : Running metaxa2_x to extract sequences matching $metaxa2_x_N conserved domains...\n";
      }

      ## Run Metaxa2_x with -N X option to extract sequences containing most conserved domains

      if ($hmmdir ne "") {
	`metaxa2_x -i $input -o $tmp/$TYPE.full-length-matching-models -p $output/HMMs/ --cpu $cpu -t $type_lc -N $metaxa2_x_N --allow_single_domain F 2>> $tmp/metaxa2_x_log.txt`;
      } else {
	`cat $tmp/$TYPE.clusters/cluster*.$TYPE.full-length.fasta > $tmp/$TYPE.full-length.fasta`;
	`metaxa2_x -i $tmp/$TYPE.full-length.fasta -o $tmp/$TYPE.full-length-matching-models -p $output/HMMs/ --cpu $cpu -t $type_lc -N $metaxa2_x_N --allow_single_domain F 2>> $tmp/metaxa2_x_log.txt`;
      }
      `mv $tmp/$TYPE.full-length-matching-models.extraction.fasta $tmp/$TYPE.full-length-matching-models.fasta`;

      $now = localtime;
      if ($silent == 0) {
	print STDERR "     $now : Reformatting sequences...\n";
      }

      ## Remove "|O|O" from identifiers

      ## Add ".X"

      $saveSeq = 0;
      $seq = "";
      $id = "";
      open (INPUT, "$tmp/$TYPE.full-length-matching-models.fasta");
      open (OUTPUT, ">$tmp/$TYPE.fasta");
      open (TAXIDDUMP, ">$tmp/$TYPE.id_dump.txt");
      while ($line = <INPUT>) {
	chomp($line);
	if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
	  if (eof(INPUT)) {
	    $seq = $seq . $line;
	  }
	  if ($id ne "") {
	    if ($hmmdir ne "") {
	      $orgid = substr($id, 0, length($id) - 2);
	      $id = substr($id, 0, length($id) - 2);
	    } else {
	      $orgid = substr($id, 0, length($id) - 4);
	      $id = substr($id, 0, length($id) - 4);
	    }
	    $id =~ s/[^A-Za-z0-9._]/_/g;
	    $id = substr($id, 1, 60);

	    print TAXIDDUMP $id . "\n";

	    $ID_to_TYPE{$id} = $TYPE;
	    if ($orgid =~ m/\|/) {
	      $acc = $id;
	      @orgid_parts = split('\|', $orgid);
	      foreach $part (@orgid_parts) {
		if ($part =~ m/[A-Z]+[0-9_]+\.[0-9]+/) {
		  $acc = $part;
		  $acc =~ s/[^A-Za-z0-9._]/_/g;
		  $acc =~ s/\.[0-9]+//;
		}
	      }
	      $ACC_to_ID{$acc} = $id;
	    } else {
	      $ACC_to_ID{$id} = $id;
	    }
	    $id = $id . "." . $TYPE;

	    print OUTPUT ">" . $id . "\n";
	    print OUTPUT uc($seq) . "\n";
	  }
	  ($id) = split(' ', $line);
	  $seq = "";
	} else {
	  $seq = $seq . $line;
	} 
      }
      close INPUT;
      close OUTPUT;
      close TAXIDDUMP;

      `cat $tmp/$TYPE.fasta >> $tmp/preblast.fasta`;

      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : End of processing for type $TYPE.\n";
	print STDERR "-----------------------------------------------------------------\n";
      }
    }
  }


  $now = localtime;
  if ($silent == 0) {
    print STDERR "$now : Building classification database...\n";
  }

  $now = localtime;
  if ($silent == 0) {
    print STDERR "     $now : Building database taxonomy...\n";
  }
  ## Create the new .taxonomy.txt file for the BLAST database
  ## Parse Metaxa2 (easy) or ASN1 (hard) format
  ## Also added FASTA format with taxonomy in the headers and NCBI/INSD XML formats

  ## Guess format
  open (TAX, $taxfile);
  chomp($line = <TAX>);
  chomp($line2 = <TAX>);
  close TAX;

  $taxformat = "Unrecognized";

  ($id, $tax) = split('\t', $line);

  if ($id ne "") {
    if ($tax =~ m/;.*;/) {
      $taxformat = "Metaxa2";
    }
  }

  if ($line =~ m/Seq-entry ::=/) {
    $taxformat = "ASN";
  }

  if ($line =~ m/^>.*;/) {
    $taxformat = "FASTA";
  }

  if ($line =~ m/xml version/) {
    if (($line2 =~ m/DOCTYPE Bioseq-set/) && ($line2 =~ m/NCBI Seqset/)) {
      $taxformat = "XML NCBI";
    }
  }

  if ($line =~ m/xml version/) {
    if (($line2 =~ m/DOCTYPE Bioseq-set/) && ($line2 =~ m/INSD INSDSeq/)) {
      $taxformat = "XML INSD";
    }
  }
  

  if ($taxformat eq "Unrecognized") {
    print STDERR "ERROR :: Format of the supplied taxonomy file cannot be recognized.\
The software will continue, but the database created will not be usable for classification.\
You can still use it for extraction of the $gene gene using metaxa2_x.\n";
    print STDERR "-----------------------------------------------------------------\n";
  }

  if ($taxformat eq "Metaxa2") {
    open (TAX, $taxfile);
    open (TAXOUT, ">$output/blast.taxonomy.txt");
    open (TAXIDDUMP, ">$tmp/taxonomy.id_dump.txt");
    while ($line = <TAX>) {
      chomp($line);
      ($id, $tax) = split('\t', $line);
      $id =~ s/[^A-Za-z0-9._]/_/g;
      $id = substr($id, 0, 60);

      print TAXIDDUMP $id . "\n";

      if (defined($ID_to_TYPE{$id})) {
	$id = $id . "." . $ID_to_TYPE{$id};
	if (($filter_uncult == 1) && ($tax =~ m/uncult|unclass|environ|sample|clone|parasite|symbiont|contamin|unknown|unident|metagenom|isolat/i)) {
	  ## Don't include this
	  undef($hasTaxInfo{$id});
	} else {
	  if ($correct_taxonomy == 1) {
	    $tax =~ s/;[a-z]__/;/g;
	    $tax =~ s/_[0-9]+;/;/g;
	    $tax =~ s/[^;]*([A-Z][a-z]*);/\1;/;
	    $tax = do_correct_taxonomy($id, $tax);
	  }
	  $max_no_levels = scalar(split(";",$tax));
	  if ($max_no_levels >= $filter_level) {
	    $hasTaxInfo{$id} = 1;
	    print TAXOUT $id . "\t" . $tax . "\n";
	    $final_tax{$id} = $tax;
	  } else {
	    undef($hasTaxInfo{$id});	  
	  }
	}
      }
    }
    close TAX;
    close TAXOUT;
    close TAXIDDUMP;
  }

  if ($taxformat eq "FASTA") {
    open (TAX, $taxfile);
    open (TAXOUT, ">$output/blast.taxonomy.txt");
    while ($line = <TAX>) {
      chomp($line);
      if (substr($line, 0 , 1) eq ">") {
	($id) = split(' ', $line);
	$header = substr($line, length($id) + 1);
	$id =~ s/[^A-Za-z0-9._]/_/g;
	$id = substr($id, 1, 60);
	$tax = $header;
	$tax =~ s/;[a-z]__/;/g;
	$tax =~ s/_[0-9]+;/;/g;
	$tax =~ s/[^;]*([A-Z][a-z]*);/\1;/;
      
	if (defined($ID_to_TYPE{$id})) {
	  $id = $id . "." . $ID_to_TYPE{$id};
	  if (($filter_uncult == 1) && ($tax =~ m/uncult|unclass|environ|sample|clone|parasite|symbiont|contamin|unknown|unident|metagenom|isolat/i)) {
	    ## Don't include this
	    undef($hasTaxInfo{$id});
	  } else {
	    if ($correct_taxonomy == 1) {
	      $tax = do_correct_taxonomy($id, $tax);
	    }
	    $max_no_levels = scalar(split(";",$tax));
	    if ($max_no_levels >= $filter_level) {
	      $hasTaxInfo{$id} = 1;
	      print TAXOUT $id . "\t" . $tax . "\n";
	      $final_tax{$id} = $tax;
	    } else {
	      undef($hasTaxInfo{$id});	  
	    }
	  }
	}
      }
    }
    close TAX;
    close TAXOUT;
  }
 
  $asnEntry = 0;
  if ($taxformat eq "ASN") {
    open (TAX, $taxfile);
    open (TAXOUT, ">$output/blast.taxonomy.txt");
    open (TAXLOG, ">$tmp/taxonomy.log.txt");
    while ($line = <TAX>) {
      chomp($line);
      if (($line =~ m/Seq-entry ::=/) || eof(TAX)) {
	$asnEntry++;
	foreach $acc (@accs) {
	  if (($acc ne "") && ($lineage ne "")) {
	    if (defined($ACC_to_ID{$acc})) {
	      $id = $ACC_to_ID{$acc};
	      if (defined($ID_to_TYPE{$id})) {
		$tax = $lineage . ";" . $taxname;
		if (($filter_uncult == 1) && ($tax =~ m/uncult|unclass|environ|sample|clone|parasite|symbiont|contamin|unknown|unident|metagenom|isolat/i)) {
		  ## Don't include this
		  undef($hasTaxInfo{$id});
		  print TAXLOG $asnEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Filtered out" . "\n";
		} else {
		  $id = $id . "." . $ID_to_TYPE{$id};
		  if ($correct_taxonomy == 1) {
		    $tax = do_correct_taxonomy($id, $tax);
		  }
		  $max_no_levels = scalar(split(";",$tax));
		  if ($max_no_levels >= $filter_level) {
		    $hasTaxInfo{$id} = 1;
		    print TAXOUT $id . "\t" . $tax . "\n";
		    $final_tax{$id} = $tax;
		    print TAXLOG $asnEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Included" . "\n";
		  } else {
		    undef($hasTaxInfo{$id});
		    print TAXLOG $asnEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Too few tax-levels" . "\n";
		  }
		}
	      } else {
		print TAXLOG $asnEntry . "\t" . $acc . "\t" . $id . "\t" . "undef" . "\t" . $lineage . ";" . $taxname . "\t" . "Not present in TYPEs" . "\n";
	      }
	    } else {
	      print TAXLOG $asnEntry . "\t" . $acc . "\t" . "undef" . "\t" . "N/A" . "\t" . $lineage . ";" . $taxname . "\t" . "Not present among IDs" . "\n";
	    }
	  } else {
	    print TAXLOG $asnEntry . "\t" . $acc . "\t" . "N/A" . "\t" . "N/A" . "\t" . $lineage . ";" . $taxname . "\t" . "Empty accession or lineage" . "\n";
	  }
	}

	$acc = "";
	undef(@accs);
	$openID = 0;
	$lineage = "";
	$taxname = "";
      }
      if ($line =~ m/  id \{/) {
	$openID = 1;
      }
      if ($line =~ m/accession "[^"]*"/) {
	if ($openID == 1) {
	  $acc = $line;
	  $acc =~ s/^.*accession "//;
	  $acc =~ s/".*//;
	  $openID = 0;
	  #	$lineage = "";
	  #	$taxname = "";
	  push(@accs, $acc);
	}
      }
      if ($line =~ m/taxname /) {
	$taxname = $line;
	$taxname =~ s/.*taxname "//;
	$taxname =~ s/".*//;
      }
      if ($line =~ m/lineage /) {
	$openLin = 1;
	$lineage = "";
      }
      if ($openLin == 1) {
	$lineage = $lineage . $line;
	if ($line =~ m/" ,/) {
	  $openLin = 0;
	  if ($lineage !~ m/[{}]/) {
	    $lineage =~ s/.*lineage "//;
	    $lineage =~ s/" ,.*//;
	    $lineage =~ s/; /;/g;
	  }
	}
      }
    }
    close TAX;
    close TAXOUT;
  }

  $xmlEntry = 0;
  if ($taxformat eq "XML NCBI") {
    open (TAX, $taxfile);
    open (TAXOUT, ">$output/blast.taxonomy.txt");
    open (TAXLOG, ">$tmp/taxonomy.log.txt");
    while ($line = <TAX>) {
      chomp($line);
      if (($line =~ m/<Seq-entry>/) || eof(TAX)) {
	$xmlEntry++;
	foreach $acc (@accs) {
	  if (($acc ne "") && ($lineage ne "")) {
	    if (defined($ACC_to_ID{$acc})) {
	      $id = $ACC_to_ID{$acc};
	      if (defined($ID_to_TYPE{$id})) {
		$tax = $lineage . ";" . $taxname;
		if (($filter_uncult == 1) && ($tax =~ m/uncult|unclass|environ|sample|clone|parasite|symbiont|contamin|unknown|unident|metagenom|isolat/i)) {
		  ## Don't include this
		  undef($hasTaxInfo{$id});
		  print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Filtered out" . "\n";
		} else {
		  $id = $id . "." . $ID_to_TYPE{$id};
		  if ($correct_taxonomy == 1) {
		    $tax = do_correct_taxonomy($id, $tax);
		  }
		  $max_no_levels = scalar(split(";",$tax));
		  if ($max_no_levels >= $filter_level) {
		    $hasTaxInfo{$id} = 1;
		    print TAXOUT $id . "\t" . $tax . "\n";
		    $final_tax{$id} = $tax;
		    print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Included" . "\n";
		  } else {
		    undef($hasTaxInfo{$id});
		    print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Too few tax-levels" . "\n";
		  }
		}
	      } else {
		print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . "undef" . "\t" . $lineage . ";" . $taxname . "\t" . "Not present in TYPEs" . "\n";
	      }
	    } else {
	      print TAXLOG $xmlEntry . "\t" . $acc . "\t" . "undef" . "\t" . "N/A" . "\t" . $lineage . ";" . $taxname . "\t" . "Not present among IDs" . "\n";
	    }
	  } else {
	    print TAXLOG $xmlEntry . "\t" . $acc . "\t" . "N/A" . "\t" . "N/A" . "\t" . $lineage . ";" . $taxname . "\t" . "Empty accession or lineage" . "\n";
	  }
	}

	$acc = "";
	undef(@accs);
	$lineage = "";
	$taxname = "";
	$genus_name = "";
	$species_name = "";
      }
      if ($line =~ m/<Textseq-id_accession>/) {
	$acc = $line;
	$acc =~ s/.*<Textseq-id_accession//;
	$acc =~ s/.*<\/Textseq-id_accession//;
	push(@accs, $acc);
      }
      if ($line =~ m/<Org-ref_taxname>/) {
	$taxname = $line;
	$taxname =~ s/.*<Org-ref_taxname>//;
	$taxname =~ s/.*<\/Org-ref_taxname>//;
      }
      if ($line =~ m/<BinomialOrgName_genus>/) {
	$genus_name = $line;
	$genus_name =~ s/.*<BinomialOrgName_genus>//;
	$genus_name =~ s/.*<\/BinomialOrgName_genus>//;
	$taxname = $genus_name . " " . $species_name;
      }
      if ($line =~ m/<BinomialOrgName_species>/) {
	$species_name = $line;
	$species_name =~ s/.*<BinomialOrgName_species>//;
	$species_name =~ s/.*<\/BinomialOrgName_species>//;
	$taxname = $genus_name . " " . $species_name;
      }
      if ($line =~ m/<OrgName_lineage>/) {
	$lineage = $line;
	$lineage =~ s/.*<OrgName_lineage>//;
	$lineage =~ s/.*<\/OrgName_lineage>//;
	$lineage =~ s/; */;/g;
      }
    }
    close TAX;
    close TAXOUT;
  }

  $xmlEntry = 0;
  if ($taxformat eq "XML INSD") {
    open (TAX, $taxfile);
    open (TAXOUT, ">$output/blast.taxonomy.txt");
    open (TAXLOG, ">$tmp/taxonomy.log.txt");
    while ($line = <TAX>) {
      chomp($line);
      if (($line =~ m/<INSDSeq>/) || eof(TAX)) {
	$xmlEntry++;
	foreach $acc (@accs) {
	  if (($acc ne "") && ($lineage ne "")) {
	    if (defined($ACC_to_ID{$acc})) {
	      $id = $ACC_to_ID{$acc};
	      if (defined($ID_to_TYPE{$id})) {
		$tax = $lineage . ";" . $taxname;
		if (($filter_uncult == 1) && ($tax =~ m/uncult|unclass|environ|sample|clone|parasite|symbiont|contamin|unknown|unident|metagenom|isolat/i)) {
		  ## Don't include this
		  undef($hasTaxInfo{$id});
		  print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Filtered out" . "\n";
		} else {
		  $id = $id . "." . $ID_to_TYPE{$id};
		  if ($correct_taxonomy == 1) {
		    $tax = do_correct_taxonomy($id, $tax);
		  }
		  $max_no_levels = scalar(split(";",$tax));
		  if ($max_no_levels >= $filter_level) {
		    $hasTaxInfo{$id} = 1;
		    print TAXOUT $id . "\t" . $tax . "\n";
		    $final_tax{$id} = $tax;
		    print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Included" . "\n";
		  } else {
		    undef($hasTaxInfo{$id});
		    print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . $ID_to_TYPE{$id} . "\t" . $lineage . ";" . $taxname . "\t" . "Too few tax-levels" . "\n";
		  }
		}
	      } else {
		print TAXLOG $xmlEntry . "\t" . $acc . "\t" . $id . "\t" . "undef" . "\t" . $lineage . ";" . $taxname . "\t" . "Not present in TYPEs" . "\n";
	      }
	    } else {
	      print TAXLOG $xmlEntry . "\t" . $acc . "\t" . "undef" . "\t" . "N/A" . "\t" . $lineage . ";" . $taxname . "\t" . "Not present among IDs" . "\n";
	    }
	  } else {
	    print TAXLOG $xmlEntry . "\t" . $acc . "\t" . "N/A" . "\t" . "N/A" . "\t" . $lineage . ";" . $taxname . "\t" . "Empty accession or lineage" . "\n";
	  }
	}

	$acc = "";
	undef(@accs);
	$lineage = "";
	$taxname = "";
      }
      if ($line =~ m/<INSDSeq_locus>/) {
	$acc = $line;
	$acc =~ s/.*<INSDSeq_locus>//;
	$acc =~ s/.*<\/INSDSeq_locus>//;
	push(@accs, $acc);
      }
      if ($line =~ m/<INSDSeq_organism>/) {
	$taxname = $line;
	$taxname =~ s/.*<INSDSeq_organism>//;
	$taxname =~ s/.*<\/INSDSeq_organism>//;
      }
      if ($line =~ m/<INSDSeq_taxonomy>/) {
	$lineage = $line;
	$lineage =~ s/.*<INSDSeq_taxonomy>//;
	$lineage =~ s/.*<\/INSDSeq_taxonomy>//;
	$lineage =~ s/; */;/g;
      }
    }
    close TAX;
    close TAXOUT;
  }

  $now = localtime;
  if ($silent == 0) {
    print STDERR "     $now : Checking correspondence between sequences and taxonomy data...\n";
  }
  ## Filter out entries from the BLAST database that does not have taxonomic information

  if (scalar(keys(%hasTaxInfo)) == 0) {
    print STDERR "WARNING :: There are no sequences left in the classification database.\
Try relaxing the cutoffs to retain more sequences. There could also be a problem with your taxonomy file.\
The software will continue, but the database created will not be usable for classification.\
You may still be able to use it for extraction of the $gene gene using metaxa2_x.\n";
    print STDERR "-----------------------------------------------------------------\n";
  }


  open (INPUT, "$tmp/preblast.fasta");
  open (OUTPUT, ">$output/blast.fasta");
  while ($line = <INPUT>) {
    chomp($line);
    if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
      if (eof(INPUT)) {
	$seq = $seq . $line;
      }
      $id = substr($id, 1);
      if ($id ne "") {
	if (defined($hasTaxInfo{$id})) {
	  print OUTPUT ">" . $id . "\n";
	  print OUTPUT uc($seq) . "\n";
	}
      }
      ($id) = split(' ', $line);
      $seq = "";
    } else {
      $seq = $seq . $line;
    } 
  }
  close INPUT;
  close OUTPUT;


  $now = localtime;
  if ($silent == 0) {
    print STDERR "     $now : Building BLAST database...\n";
  }
  ## formatdb

  if ($blast_plus == 0) {
    `formatdb -i $output/blast.fasta -n $output/blast -t "Metaxa2 $gene Custom Classification Database" -o T -p F`;
  } else {
    `makeblastdb -in $output/blast.fasta -out $output/blast -title "Metaxa2 $gene Custom Classification Database" -parse_seqids -dbtype nucl`;
  }

  if ($cutoffs eq "") {
  
    $now = localtime;
    if ($silent == 0) {
      print STDERR "$now : Determining cutoffs...\n";
    }
  
    ## Just to make sure there are some cutoffs there in the first place...
    open (CUTOFFS, ">$output/blast.cutoffs.txt");
    print CUTOFFS "0,60,70,75,85,90,97"; ## These are just taken from the SSU db of Metaxa2...
    close CUTOFFS;
  
    open (CUTOFFLOG, ">$tmp/cutoff_identities.txt");
    print CUTOFFLOG "Taxlevel\tPair\tID_i\tID_j\tTaxa_i\tTaxa_j\tPercent identity\tAlignment length\tIdentities\tMismatches\tDouble gaps\n";
  
    $resulting_nseq = `grep -c ">" $output/blast.fasta`;  
    if ($resulting_nseq < 10) {
      print STDERR "     $now : Determining cutoffs not meaningful, less than ten sequences in BLAST database. Will use Metaxa2 default cutoffs.\n";
    } else {
      $now = localtime;
      if ($silent == 0) {
	print STDERR "     $now : Aligning...\n";
      }
      `mafft --auto --reorder --quiet --thread $cpu $output/blast.fasta > $tmp/final_blast_aligned.afa`;
      $resulting_nseq = `grep -c ">" $tmp/final_blast_aligned.afa`;  
      if ($resulting_nseq == 0) {
	print STDERR "ERROR! No sequences in alignment when determining cutoffs. The BLAST database for classification may be faulty.\n";
      } else {
	$saveSeq = 0;
	$seq = "";
	$id = "";
	$sample_prob = $sample_aim / $resulting_nseq;
	if ($sample_prob > 1) {
	  $sample_prob = 1;
	}
	undef %final_aln;
	open (INPUT, "$tmp/final_blast_aligned.afa");
	while ($line = <INPUT>) {
	  chomp($line);
	  if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
	    if (substr($line, 0, 1) ne ">") {
	      $seq = $seq . $line;
	    }
	    if ($id ne "") {
	      if (rand() < $sample_prob) {
		$final_aln{$id} = $seq;
	      }
	    }
	    ($id) = split(' ', $line);
	    $id = substr($id, 1);
	    $seq = "";
	  } else {
	    $seq = $seq . $line;
	  } 
	}
	close INPUT;
	@sorted_ids = sort(keys(%final_aln));
      
	for ($taxlevel = 1; $taxlevel <= 6; $taxlevel++) {
	  $now = localtime;
	  if ($silent == 0) {
	    if ($taxlevel == 6) {
	      print STDERR "     $now : Determining species cutoff...\n";
	    }
	    if ($taxlevel == 5) {
	      print STDERR "     $now : Determining genus cutoff...\n";
	    }
	    if ($taxlevel == 4) {
	      print STDERR "     $now : Determining family cutoff...\n";
	    }
	    if ($taxlevel == 3) {
	      print STDERR "     $now : Determining order cutoff...\n";
	    }
	    if ($taxlevel == 2) {
	      print STDERR "     $now : Determining class cutoff...\n";
	    }
	    if ($taxlevel == 1) {
	      print STDERR "     $now : Determining phylum cutoff...\n";
	    }
	  }
	  $intra_diff_tot{$taxlevel} = 0;
	  $intra_diff_count{$taxlevel} = 0;
	  $intra_diff_min{$taxlevel} = 100 - (7 - $taxlevel);
	  $intra_diff_max{$taxlevel} = 0;
	  $inter_diff_min{$taxlevel} = 100 - (10 - $taxlevel);
	  $inter_diff_max{$taxlevel} = 0;
	  undef(@all_intra_diffs);
	  undef(@all_inter_diffs);
	  for ($i = 0; $i < scalar(@sorted_ids); $i++) {
	    $id_i = @sorted_ids[$i];
	    $seq_i = $final_aln{$id_i};
	    $tax_i = $final_tax{$id_i};
	    @taxlevels_i = split(';', $tax_i);
	    $relevant_tax_i = @taxlevels_i[$taxlevel];
	    for ($j = $i+1; $j < scalar(@sorted_ids); $j++) {
	      $id_j = @sorted_ids[$j];
	      $seq_j = $final_aln{$id_j};
	      $tax_j = $final_tax{$id_j};
	      @taxlevels_j = split(';', $tax_j);	
	      $relevant_tax_j = @taxlevels_j[$taxlevel];
	      $identities = 0;
	      $double_gaps = 0;
	      $mismatches = 0;
	      $matching_len = 0;
	      for ($bp = 0; $bp < length($seq_i); $bp++) {
		if (substr($seq_i, $bp, 1) eq substr($seq_j, $bp, 1)) {
		  if ((substr($seq_i, $bp, 1) ne "-") && (substr($seq_i, $bp, 1) ne ".")) {
		    $identities++;
		    $matching_len++;
		  } else {
		    $double_gaps++;
		  }
		} else {
		  $mismatches++;
		  $matching_len++;
		}
	      }
	      if ($matching_len > 0) {
		$percent_identity = $identities / $matching_len * 100;
	      } else {
		$percent_identity = 0;
	      }
	      print CUTOFFLOG "$taxlevel\t$i <--> $j\t" . $id_i . "\t" .  $id_j . "\t" . $relevant_tax_i . "\t" .  $relevant_tax_j . "\t" . $percent_identity . "\t" . $matching_len . "\t" . $identities . "\t" . $mismatches . "\t" . $double_gaps . "\t";
	    
	      if ($relevant_tax_i eq $relevant_tax_j) {
		print CUTOFFLOG "Intra\n";
		push(@all_intra_diffs, $percent_identity);
		$intra_diff_tot{$taxlevel} = $intra_diff_tot{$taxlevel} + $percent_identity;
		$intra_diff_count{$taxlevel} = $intra_diff_count{$taxlevel} + 1;
		if ($intra_diff_max{$taxlevel} < $percent_identity) {
		  $intra_diff_max{$taxlevel} = $percent_identity;
		}
		if ($intra_diff_min{$taxlevel} > $percent_identity) {
		  $intra_diff_min{$taxlevel} = $percent_identity;
		}
	      } else {
		print CUTOFFLOG "Inter\n";
		push(@all_inter_diffs, $percent_identity);
		$inter_diff_tot{$taxlevel} = $inter_diff_tot{$taxlevel} + $percent_identity;
		$inter_diff_count{$taxlevel} = $inter_diff_count{$taxlevel} + 1;
		if ($inter_diff_max{$taxlevel} < $percent_identity) {
		  $inter_diff_max{$taxlevel} = $percent_identity;
		}
		if ($inter_diff_min{$taxlevel} > $percent_identity) {
		  $inter_diff_min{$taxlevel} = $percent_identity;
		}
	      }
	    }
	  }
	  if ($inter_diff_count{$taxlevel} > 0) {
	    $mean_inter_diff = $inter_diff_tot{$taxlevel} / $inter_diff_count{$taxlevel};
	  } else {
	    $mean_inter_diff = 0;
	  }
	  @sorted_intra_diffs = sort(@all_intra_diffs);
	  @sorted_inter_diffs = sort(@all_inter_diffs);
	  $inter_95 = @sorted_inter_diffs[int($inter_diff_count{$taxlevel} * 0.95)];
	  $intra_05 = @sorted_intra_diffs[int($inter_diff_count{$taxlevel} * 0.05)];

	  if ($mean_inter_diff < $inter_diff_max{$taxlevel}) {
	    if ($mean_inter_diff > $inter_diff_min{$taxlevel}) {
	      $inter_taxa_cutoff{$taxlevel} = $inter_95;
	      print STDERR "          Inter-taxa cutoff: " . substr($inter_taxa_cutoff{$taxlevel}, 0, 6) . "\n";
	    } else {
	      $inter_taxa_cutoff{$taxlevel} = $inter_95;
	      print STDERR "          Inter-taxa cutoff: " . substr($inter_taxa_cutoff{$taxlevel}, 0, 6) . " (Warning: poor sampling at this taxonomic level)\n";
	    }
	  } else {
	    $inter_taxa_cutoff{$taxlevel} = 0;
	    print STDERR "          No meaningful inter-taxa cutoff, only one taxonomic group detected.\n";
	  }
	
	  if ($intra_diff_count{$taxlevel} > 0) {
	    $mean_intra_diff = $intra_diff_tot{$taxlevel} / $intra_diff_count{$taxlevel};
	  } else {
	    $mean_intra_diff = 0;
	  }
	  if ($mean_intra_diff < $intra_diff_max{$taxlevel}) {
	    if ($mean_intra_diff > $intra_diff_min{$taxlevel}) {
	      $intra_taxa_cutoff{$taxlevel} = $intra_05;
	      print STDERR "          Intra-taxa cutoff: " . substr($intra_taxa_cutoff{$taxlevel}, 0, 6) . "\n";
	    } else {
	      $intra_taxa_cutoff{$taxlevel} = $intra_05;
	      print STDERR "          Intra-taxa cutoff: " . substr($intra_taxa_cutoff{$taxlevel}, 0, 6) . " (Warning: poor sampling at this taxonomic level)\n";
	    }
	  } else {
	    $intra_taxa_cutoff{$taxlevel} = 0;
	    print STDERR "          No meaningful intra-taxa cutoff, all groups were singletons.\n";
	  }
	  if ($intra_taxa_cutoff{$taxlevel} >= $inter_taxa_cutoff{$taxlevel}) {
	    $final_cutoff{$taxlevel} = $intra_taxa_cutoff{$taxlevel} - ((($intra_taxa_cutoff{$taxlevel} - 1) - $inter_taxa_cutoff{$taxlevel}) / 2) * 0.2;
	  } else {
	    if ($inter_taxa_cutoff{$taxlevel} > 0) {
	      $final_cutoff{$taxlevel} = $inter_taxa_cutoff{$taxlevel};
	      if ($inter_taxa_cutoff{$taxlevel} > 99) {
		$final_cutoff{$taxlevel} = 99;
	      }
	    } else {
	      if ($intra_taxa_cutoff{$taxlevel} > 1) {
		$final_cutoff{$taxlevel} = $intra_taxa_cutoff{$taxlevel} - 1;
	      } else {
		$final_cutoff{$taxlevel} = 0;
	      }
	    }
	  }
	  print STDERR "          Final cutoff for taxonomic level: " . substr($final_cutoff{$taxlevel}, 0, 6) . "\n";      
	}
      
	$now = localtime;
	if ($silent == 0) {
	  print STDERR "     $now : Writing cutoffs...\n";
	}
	$cutoffs = "0";
	open (CUTOFFS, ">$output/blast.cutoffs.txt");
	print CUTOFFS "0";
	for ($taxlevel = 1; $taxlevel <= 6; $taxlevel++) {
	  $writeCut = substr($final_cutoff{$taxlevel}, 0, 6);
	  print CUTOFFS "," . $writeCut;      
	  $cutoffs = $cutoffs . "," . $writeCut;
	}
	close CUTOFFS;
	close CUTOFFLOG;
      }
    }
  } else {
    $now = localtime;
    if ($silent == 0) {
      print STDERR "     $now : Writing cutoffs...\n";
    }
    open (CUTOFFS, ">$output/blast.cutoffs.txt");
    print CUTOFFS $cutoffs;
    close CUTOFFS;
  }
} else {			## If --db option was specified
  $output = $evalDB;
}
  
if ($evaluate == 1) {
  $now = localtime;
  if ($silent == 0) {
    print STDERR "-----------------------------------------------------------------\n";
    print STDERR "$now : Running statistical evaluation...\n";
  }

  $totalSequences = `grep -c ">" $output/blast.fasta`;

  foreach $testsize (@test_sets) {
    $now = localtime;
    if ($silent == 0) {
      print STDERR "-----------------------------------------------------------------\n";
      print STDERR "$now : Evaluating test proportion $testsize...\n";
    }    
    $testno = int($totalSequences * $testsize);
    $trainno = $totalSequences - $testno;
    run_evaluation($trainno, $testno, $testsize);

    `cp $tmp/eval/evaluation_statistics.$testsize.overall.txt $output/evaluation_statistics.$testsize.txt`;
  }
}

if ($save_raw == 1) {
  `mv $tmp $output/raw_data`;
} else {
  `rm -rf $tmp`;
}

$now = localtime;
if ($silent == 0) {
  print STDERR "$now : Metaxa2 Database Builder is finished.\n";
  print STDERR "-----------------------------------------------------------------\n";
  print STDERR "Database can be found in $output\n";
}

sub do_correct_taxonomy {
  my $ct_id = shift;
  my $ct_tax = shift;

  my $starttax = $ct_tax;
  if (($starttax =~ m/Metazoa/) || ($starttax =~ m/Animalia/)) {
    my $entry_metazoan = 1;
  } else {
    my $entry_metazoan = 0;
  }
  $starttax =~ s/[^A-Za-z0-9 ;_\-'"]/ /g;
  $starttax =~ s/.*Chlorophyta;/Eukaryota;Viridiplantae;Chlorophyta;/;
  $starttax =~ s/.*Streptophyta;/Eukaryota;Viridiplantae;Streptophyta;/;
  $starttax =~ s/.*Chloroplast;/Chloroplast;/;
  $starttax =~ s/.*chloroplast;/Chloroplast;/;
  $starttax =~ s/.*Mitochondria;/Mitochondria;/;
  $starttax =~ s/.*mitochondria;/Mitochondria;/;
  my @taxonlevels = split(';', $starttax);
  ## Sort out the phylum level
  my $phylum_level = 1;
  foreach $phylum (@list_of_phyla) {
    for (my $tl = 0; $tl < scalar(@taxonlevels); $tl++) {
      my $tax_at_level = @taxonlevels[$tl];
      if ($tax_at_level =~ m/^$phylum/) {
	$phylum_level = $tl;
	last;
      }
    }
  }
  ## Sort out the order level
  my $order_level = 0;
  for ($tl = $phylum_level + 1; $tl < scalar(@taxonlevels); $tl++) {
    $tax_at_level = @taxonlevels[$tl];
    if ($tax_at_level =~ m/ales$/) {
      if ($entry_metazoan == 0) {
	$order_level = $tl;
	last;
      }
    }
  }
  if ($order_level == 0) {
    for ($tl = $phylum_level + 1; $tl < scalar(@taxonlevels); $tl++) {
      $tax_at_level = @taxonlevels[$tl];
      if ($tax_at_level =~ m/ales/) {
	if ($entry_metazoan == 0) {
	  $order_level = $tl;
	  last;
	}
      }
    }
  }
  if ($order_level == 0) {
    $order_level = $phylum_level + 2;
  }
		  
  ## Sort out the class level
  my $class_level = $order_level - 1;
  for ($tl = $class_level - 1; $tl > $phylum_level; $tl--) {
    $tax_at_level = @taxonlevels[$tl];
    if ($tax_at_level =~ m/^[A-Z]/) {
      $class_level = $tl;
      last;
    }
  }
  
  ## Sort out the family level
  my $family_level = 0;
  for ($tl = $order_level + 1; $tl < scalar(@taxonlevels); $tl++) {
    $tax_at_level = @taxonlevels[$tl];
    if ($entry_metazoan == 0) {
      if ($tax_at_level =~ m/ceae$/) {
	$family_level = $tl;
	last;
      }
    } else {
      if ($tax_at_level =~ m/idae$/) {
	$family_level = $tl;
	last;
      }
    }
  }
  if ($family_level == 0) {
    for ($tl = $order_level + 1; $tl < scalar(@taxonlevels); $tl++) {
      $tax_at_level = @taxonlevels[$tl];
      if ($entry_metazoan == 0) {
	if ($tax_at_level =~ m/ceae/) {
	  $family_level = $tl;
	  last;
	}
      } else {
	if ($tax_at_level =~ m/idae$/) {
	  $family_level = $tl;
	  last;
	}
      }
    }
  }
  if ($family_level == 0) {
    $family_level = $order_level + 1;
  }
  
  ## Sort out the species level
  my $species_level = 0;
  for ($tl = $family_level + 1; $tl < scalar(@taxonlevels); $tl++) {
    $tax_at_level = @taxonlevels[$tl];
    if ($tax_at_level =~ m/^[A-Z][a-z]+ [a-z]+$/) {
      $species_level = $tl;
      last;
    }
  }
  if ($species_level == 0) {
    for ($tl = $family_level + 1; $tl < scalar(@taxonlevels); $tl++) {
      $tax_at_level = @taxonlevels[$tl];
      if ($tax_at_level =~ m/^[A-Z][a-z]+ [a-z]+/) {
	$species_level = $tl;
	@taxonlevels[$tl] =~ s/^([A-Z][a-z]+ [a-z]+).*/\1/;
	last;
      }
    }
  }
  if ($species_level == 0) {
    $species_level = scalar(@taxonlevels) - 1;
  }
  
  ## Sort out the genus level
  my $genus_level = 0;
  for ($tl = $species_level - 1; $tl > $family_level; $tl--) {
    $tax_at_level = @taxonlevels[$tl];
    my $species_designation = @taxonlevels[$species_level];
    (my $pot_gen, my $pot_species) = split(' ', $species_designation);
    if ($pot_gen eq $tax_at_level) {
      $genus_level = $tl;
      last;
    }
  }
  if ($genus_level == 0) {
    for ($tl = $species_level - 1; $tl > $family_level; $tl--) {
      $tax_at_level = @taxonlevels[$tl];
      my $species_designation = @taxonlevels[$species_level];
      (my $pot_gen, my $pot_species) = split(' ', $species_designation);
      if ($tax_at_level =~ m/$pot_gen/) {
	$genus_level = $tl;
	last;
      }
    }
  }
  if ($genus_level == 0) {
    $genus_level = $family_level + 1;
  }
  
  my $endtax = @taxonlevels[0] . ";" . @taxonlevels[$phylum_level] . ";" . @taxonlevels[$class_level] . ";" . @taxonlevels[$order_level] . ";" . @taxonlevels[$family_level] . ";" . @taxonlevels[$genus_level] . ";" . @taxonlevels[$species_level];
  
  return $endtax;
}

sub run_evaluation {
  my $trainsetsize = shift;
  my $testsetsize = shift;
  my $testsetprop = shift;
  my $totalSeqs = $trainsetsize + $testsetsize;

  undef %correct_taxdata;
  undef %eval_results;
  $now = localtime;
  if ($silent == 0) {
    print STDERR "     $now : Parsing correct taxonomy data...\n";
  }

  open (TAXDATA, "$output/blast.taxonomy.txt");
  while ($line = <TAXDATA>) {
    chomp($line);
    ($id, $tax) = split('\t', $line);
    @ctax_levels = split(';', $tax);
    for ($ctax_level = 0; $ctax_level < 7; $ctax_level++) {
      $correct_taxdata{"$id\t$ctax_level"} = @ctax_levels[$ctax_level];
    }
  }
  close TAXDATA;
  
  open (CUTDATA, "$output/blast.cutoffs.txt");
  $line = <CUTDATA>;
  chomp($line);
  $eval_db_cutoffs = $line;
  close CUTDATA;
  

  undef %dbsSeqs;
  open (INPUT, "$output/blast.fasta");
  while ($line = <INPUT>) {
    chomp($line);
    if ((substr($line, 0, 1) eq ">") || eof(INPUT)) {
      if (eof(INPUT)) {
	$seq = $seq . $line;
      }
      $id = substr($id, 1);
      if ($id ne "") {
	if ($seq ne "") {
	  $dbsSeqs{$id} = $seq;
	}
      }
      ($id) = split(' ', $line);
      $seq = "";
    } else {
      $seq = $seq . $line;
    }   
  }
  #$dbsSeqs{$id} = $seq;
  close INPUT;
  `mkdir $tmp/eval`;
  @ids = keys(%dbsSeqs);
  $totalIDS = scalar(@ids);

  for ($iter = 0; $iter < $iterations; $iter++) {
    undef %picked;

    open (TESTSET, ">$tmp/eval/test_seq.fasta");

    $testseqsleft = $testsetsize;
    until ($testseqsleft == 0) {
      $rnum = int(rand() * $totalIDS);
      if (defined($picked{$rnum})) {
	next;
      } else {
	$picked{$rnum} = 1;
	if ($dbsSeqs{@ids[$rnum]} ne "") {
	  print TESTSET ">" . @ids[$rnum] . "\n";
	  print TESTSET $dbsSeqs{@ids[$rnum]} . "\n";
	}
	$testseqsleft--;
      }
    }
    close TESTSET;

    #open (TRAINSET, ">$tmp/eval/train_seq.fasta");
    `rm $tmp/eval/train_seq.*.fasta 2>/dev/null`;
    $num = 0;
    undef %pickTYPE;
    foreach $id (@ids) {
      if (defined($picked{$num})) {
	## Do nothing
      } else {
	$thisTYPE = substr(@ids[$num],-1);
	$pickTYPE{$thisTYPE} = 1;
	open (TRAINSET, ">>$tmp/eval/train_seq.$thisTYPE.fasta");
	print TRAINSET ">" . @ids[$num] . "\n";
	print TRAINSET $dbsSeqs{@ids[$num]} . "\n";
	close TRAINSET;
      }
      $num++;
    }
    #close TRAINSET;

    $trainsets = "";
    foreach $thisTYPE (keys(%pickTYPE)) {
      $trainsets = $trainsets . "-" . lc($thisTYPE) . " $tmp/eval/train_seq.$thisTYPE.fasta ";
    }

    $now = localtime;
    if ($silent == 0) {
      print STDERR "     $now : Re-building database, iteration $iter...\n";
    }

    `rm -rf $tmp/eval/TRAIN`;
    `rm -rf $tmp/eval/TEST*`;

    chomp($path = `which metaxa2_dbb`); # Get the path for metaxa2_dbb
    if ($path eq "") { # If the path is empty, then use this executable itself
      if ($hmmdir eq "") {
	`$bindir/metaxa2_dbb $trainsets -o "$tmp/eval/TRAIN" -g "$gene" -t "$output/blast.taxonomy.txt" --cpu $cpu --full_length $full_length --cutoffs "$eval_db_cutoffs" -C $C -N $N -A $A -P $P -L $L -M $M --plus "$blast_plus" --single_profile $single_profile --divergent $divergent_mode 2>&1 | tee -a $tmp/eval/eval_log.txt`;
      } else {
	`$bindir/metaxa2_dbb $trainsets -o "$tmp/eval/TRAIN" -p $hmmdir -g "$gene" -t "$output/blast.taxonomy.txt" --cpu $cpu --full_length $full_length --cutoffs "$eval_db_cutoffs" -C $C -N $N -A $A -P $P -L $L -M $M --plus "$blast_plus" --single_profile $single_profile --divergent $divergent_mode 2>&1 | tee -a $tmp/eval/eval_log.txt`;
      }
    } else {
      if ($hmmdir eq "") {
	`metaxa2_dbb $trainsets -o "$tmp/eval/TRAIN" -g "$gene" -t "$output/blast.taxonomy.txt" --cpu $cpu --full_length $full_length --cutoffs "$eval_db_cutoffs" -C $C -N $N -A $A -P $P -L $L -M $M --plus "$blast_plus" --single_profile $single_profile --divergent $divergent_mode 2>&1 | tee -a $tmp/eval/eval_log.txt`;
      } else {
	`metaxa2_dbb $trainsets -o "$tmp/eval/TRAIN" -p $hmmdir -g "$gene" -t "$output/blast.taxonomy.txt" --cpu $cpu --full_length $full_length --cutoffs "$eval_db_cutoffs" -C $C -N $N -A $A -P $P -L $L -M $M --plus "$blast_plus" --single_profile $single_profile --divergent $divergent_mode 2>&1 | tee -a $tmp/eval/eval_log.txt`;
      }
    }


    $now = localtime;
    if ($silent == 0) {
      print STDERR "     $now : Classifying testing sequences...\n";
    }
    `metaxa2 -d $tmp/eval/TRAIN/blast -p $tmp/eval/TRAIN/HMMs -i $tmp/eval/test_seq.fasta -o $tmp/eval/TEST --taxonomy T --plus "$blast_plus" --cpu $cpu 2>&1 | tee -a $tmp/eval/eval_log.txt`;

    $now = localtime;
    if ($silent == 0) {
      print STDERR "     $now : Comparing correct and predicted taxonomy information...\n";
    }

    undef %test_taxdata;
    undef @test_ids;

    open (LOG, ">>$tmp/eval/eval_log.txt");
    print LOG "Comparison of taxonomy:\n";
    print LOG "Sequence ID\tTaxlevel\tEvaluated taxdata\tCorrect taxdata\n";

    open (TAXDATA, "$tmp/eval/TEST.taxonomy.txt");
    while ($line = <TAXDATA>) {
      chomp($line);
      ($id, $tax) = split('\t', $line);
      push(@test_ids, $id);
      @ctax_levels = split(';', $tax);
      for ($ctax_level = 0; $ctax_level < 7; $ctax_level++) {
	$test_taxdata{"$id\t$ctax_level"} = @ctax_levels[$ctax_level];
      }
    }
    close TAXDATA;
  
    undef %sub_eval_results;

    foreach $id (@test_ids) {
      for ($ctax_level = 0; $ctax_level < 7; $ctax_level++) {
	if (defined($test_taxdata{"$id\t$ctax_level"})) {
	  if ($test_taxdata{"$id\t$ctax_level"} eq $correct_taxdata{"$id\t$ctax_level"}) {
	    if (defined($sub_eval_results{"$ctax_level correct"})) {
	      $sub_eval_results{"$ctax_level correct"}++;
	    } else {
	      $sub_eval_results{"$ctax_level correct"} = 1;
	    }
	    print LOG $id . "\t" . $ctax_level . "\t" . $test_taxdata{"$id\t$ctax_level"} . " = " . $correct_taxdata{"$id\t$ctax_level"} . "\n";
	  } else {
	    if (defined($sub_eval_results{"$ctax_level incorrect"})) {
	      $sub_eval_results{"$ctax_level incorrect"}++;
	    } else {
	      $sub_eval_results{"$ctax_level incorrect"} = 1;
	    }
	    print LOG $id . "\t" . $ctax_level . "\t" . $test_taxdata{"$id\t$ctax_level"} . " ≠ " . $correct_taxdata{"$id\t$ctax_level"} . "\n";
	  }
	} else {
	  if (defined($sub_eval_results{"$ctax_level missing"})) {
	    $sub_eval_results{"$ctax_level missing"}++;
	  } else {
	    $sub_eval_results{"$ctax_level missing"} = 1;
	  }
	  print LOG $id . "\t" . $ctax_level . "\t" . "Missing data -> " . $correct_taxdata{"$id\t$ctax_level"} . "\n";
	}
      }
    }
    close LOG;

    open (RESULTS, ">$tmp/eval/evaluation_statistics.$testsetprop.$iter.txt");
    print RESULTS "Taxlevel\tCorrect\tProportion\tIncorrect\tProportion\tMissing\tProportion\n";
    for ($ctax_level = 0; $ctax_level < 7; $ctax_level++) {
      print RESULTS ($ctax_level + 1) . "\t";
      if (defined($sub_eval_results{"$ctax_level correct"})) {
	print RESULTS $sub_eval_results{"$ctax_level correct"};
	print RESULTS "\t";
	print RESULTS $sub_eval_results{"$ctax_level correct"} / scalar(@test_ids);
	print RESULTS "\t";
      } else {
	print RESULTS "0\t0\t";
      }
      if (defined($sub_eval_results{"$ctax_level incorrect"})) {
	print RESULTS $sub_eval_results{"$ctax_level incorrect"};
	print RESULTS "\t";
	print RESULTS $sub_eval_results{"$ctax_level incorrect"} / scalar(@test_ids);
	print RESULTS "\t";
      } else {
	print RESULTS "0\t0\t";
      }
      if (defined($sub_eval_results{"$ctax_level missing"})) {
	print RESULTS $sub_eval_results{"$ctax_level missing"};
	print RESULTS "\t";
	print RESULTS $sub_eval_results{"$ctax_level missing"} / scalar(@test_ids);
	print RESULTS "\n";
      } else {
	print RESULTS "0\t0\n";
      }
      if (defined($eval_results{"$ctax_level correct"})) {
	$eval_results{"$ctax_level correct"} = $eval_results{"$ctax_level correct"} + $sub_eval_results{"$ctax_level correct"} / scalar(@test_ids);
      } else {
	$eval_results{"$ctax_level correct"} = $sub_eval_results{"$ctax_level correct"} / scalar(@test_ids);
      }
      if (defined($eval_results{"$ctax_level incorrect"})) {
	$eval_results{"$ctax_level incorrect"} = $eval_results{"$ctax_level incorrect"} + $sub_eval_results{"$ctax_level incorrect"} / scalar(@test_ids);
      } else {
	$eval_results{"$ctax_level incorrect"} = $sub_eval_results{"$ctax_level incorrect"} / scalar(@test_ids);
      }
      if (defined($eval_results{"$ctax_level missing"})) {
	$eval_results{"$ctax_level missing"} = $eval_results{"$ctax_level missing"} + $sub_eval_results{"$ctax_level missing"} / scalar(@test_ids);
      } else {
	$eval_results{"$ctax_level missing"} = $sub_eval_results{"$ctax_level missing"} / scalar(@test_ids);
      }
    }
    close RESULTS;
  }
  
  $now = localtime;
  if ($silent == 0) {
    print STDERR "     $now : Writing final evaluation results...\n";
  }

  open (RESULTS, ">$tmp/eval/evaluation_statistics.$testsetprop.overall.txt");
  print RESULTS "Taxlevel\tCorrect\tIncorrect\tMissing\n";
  for ($ctax_level = 0; $ctax_level < 7; $ctax_level++) {
    print RESULTS ($ctax_level + 1) . "\t";
    if (defined($eval_results{"$ctax_level correct"})) {
      print RESULTS $eval_results{"$ctax_level correct"} / $iterations;
      print RESULTS "\t";
    } else {
      print RESULTS "0\t";
    }
    if (defined($eval_results{"$ctax_level incorrect"})) {
      print RESULTS $eval_results{"$ctax_level incorrect"} / $iterations;
      print RESULTS "\t";
    } else {
      print RESULTS "0\t";
    }
    if (defined($eval_results{"$ctax_level missing"})) {
      print RESULTS $eval_results{"$ctax_level missing"} / $iterations;
      print RESULTS "\n";
    } else {
      print RESULTS "0\n";
    }
  }
  close RESULTS;
}
