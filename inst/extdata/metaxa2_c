#!/usr/bin/perl
# Metaxa Classifier
$app_title     = "Metaxa Classifier -- Classifies (predicted) barcoding genes";
$app_author    = "Johan Bengtsson-Palme, University of Gothenburg";
$app_version   = "2.2";
$app_message   = "";
# ----------------------------------------------------------------- #

# License information
$license =
  "    metaxa2_c -- Metaxa Classifier -- Classifies (predicted) barcoding genes\
    Copyright (C) 2011-2018 Johan Bengtsson-Palme\
\
    This program is free software: you can redistribute it and/or modify\
    it under the terms of the GNU General Public License as published by\
    the Free Software Foundation, either version 3 of the License, or\
    (at your option) any later version.\
\
    This program is distributed in the hope that it will be useful,\
    but WITHOUT ANY WARRANTY; without even the implied warranty of\
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\
    GNU General Public License for more details.\
\
    You should have received a copy of the GNU General Public License\
    along with this program, in a file called 'license.txt'\
    If not, see: http://www.gnu.org/licenses/.\
";

## BUGS:
$bugs = "New features in this version ($app_version):\
- Added support for additional barcoding genes\
- Improved the classification scoring model for better clarity and sensitivity\
- Added output of probable taxonomic origin for sequences with reliability scores at each rank, (--reltax option)\
- Improved memory handling for very large rRNA datasets (millions of sequences)\
\
Fixed bugs in this version ($app_version):\
- None\
\
Known bugs in this version ($app_version):\
- None\
";

## OPTIONS:
$options = "\
-i {file} : DNA FASTA input file of rRNA sequences to investigate\
-o {file} : Base for the names of output file(s)\
-d {database} : The BLAST databased used for classification, default is in the same directory as metaxa itself\
--date {T or F} : Adds a date and time stamp to the output directory, off (F) by default\

Sequence selection options:\
-t {b, bacteria, a, archaea, e, eukaryota, m, mitochondrial, c, chloroplast, A, all, o, other} : Profile set to use for the search (comma-separated), default is all\
-g {ssu, lsu, string} : Specifies the barcoding gene Metaxa should look for, default is ssu\
--mode {m, metagenome, g, genome, a, auto} : Controls the Metaxa2 operating mode, default = metagenome\
-E {value} : Domain E-value cutoff for a sequence to be included in the output, default = 1\
-S {value} : Domain score cutoff for a sequence to be included in the output, default = 12\
-M {value} : Number of sequence matches to consider for classification, default = 5\
-R {value} : Reliability cutoff for taxonomic classification, default = 75\
-T {comma-separated values} : Sets the percent identity cutoff to be classified at a certain taxonomic level\
                              Order of the values is: Kingdom/Domain,Phylum,Class,Order,Family,Genus,Species
                              Default values are:     0,60,70,75,85,90,97
--scoring_model {new, old} : Selects the scoring model to be used for classification, select 'old' to use the pre 2.2 scoring model, default = new\
-H {value} : The number of points that the Metaxa Extractor prediction is given, default is the same as the number of sequences (-M option)\
--blast_eval {value} : The E-value cutoff used in the BLAST search, high numbers may slow down the process, cannot be used with the --blast_score option, default is 1e-5\
--blast_score {value} : The score cutoff used in the BLAST search, low numbers may slow down the process, cannot be used with the --blast_eval option, default is to used E-value cutoff, not score\
--blast_wordsize {value} : The word-size used for the BLAST-based classification, default is 14\
--cpu {value} : the number of CPU threads to use, default is 1\
--megablast {T or F} : Uses megablast for classification for better speed but less accuracy, off (F) by default\
--plus {T or F} : Runs blast search through blast+ instead of the legacy blastall engine, off (F) by default\
--usearch {version} : Runs usearch instead of blast, specify version, off (0) by default\
--usearch_bin {path} : Specifies the location of the Usearch binary to be used, default is 'usearch' only\
--ublast {T or F} : Runs the Ublast algorithm instead of Usearch algorithm, default is on (T)\
--reference {file} : A file in FASTA format containing reference sequences to be sent to a separate file in the analysis, default is blank (unused)\
--ref_identity {value} : The sequence identity cutoff to be considered a sequence to be derived from a reference entry, default = 99\

Output options:\
--summary {T or F} : Summary of results output, on (T) by default\
--fasta {T or F} : FASTA-format output of extracted rRNA sequences, on (T) by default\
--split_pairs {T or F} : Outputs the two read pairs separately, off (F) by default\
--table {T or F} : Table format output of sequences containing probable rRNAs, off (F) by default\
--taxonomy {T or F} : Table format output of probable taxonomic origin for sequences, on (T) by default\
--reltax {T or F} : Output of probable taxonomic origin for sequences with reliability scores at each rank, off (F) by default\
--taxlevel {integer} : Force Metaxa to classify sequences at a certain taxonomy level, regardless of reliability score, off (0) by default\
--align {a, all, u, uncertain, n, none} : Outputs alignments of BLAST matches to query in all, uncertain or no cases, requires MAFFT to be installed, default is 'none'\
--guess_species {T or F} : Writes a species guess (which can be pretty far off) to the FASTA definition line, off (F) by default (depreciated option, use --taxonomy instead)\
--not_found {T or F} : Saves a list of non-found entries, off (F) by default\
--silent {T or F} : Supresses printing progress info to stderr, off (F) by default\
--save_raw {T or F} : saves all raw data for searches etc. instead of removing it on finish, off (F) by default\

-h : displays this help message\
--help : displays this help message\
--bugs : displays the bug fixes and known bugs in this version of Metaxa\
--license : displays licensing information\
";


## Print title message
print STDERR "$app_title\nby $app_author\nVersion: $app_version\n$app_message";
print STDERR "-----------------------------------------------------------------\n";

## Setup default variable values
use List::Util qw(first max maxstr min minstr reduce shuffle sum);

$bindir = $0;
$bindir =~ s/metaxa2_c$//;
$input = "";
$output = "metaxa_out";
$blastDB = "";
$type = "all";
$gene = "ssu";
$E = 1e-3;
$S = 0;
$M = 5;
$H = -1;
$W = 14;
$T = "default";
$C = 75;
$blast_eval = 1e-5;
$blast_score = "";
$scoring_model = "new";
$cpu = 1;
$multi_thread = "unset";
$megablast = "F";
$out_sum = 1;
$out_fasta = 1;
$out_tax = 1;
$out_reltax = 0;
$out_table = 0;
$out_not = 0;
$out_align = "n";
$out_date = 0;
$split_pairs = 0;
$tax_level = 0;
$guess_species = 0;
$debug = 0;
$pipeline = 0;
$plus = 0;
$usearch = 0;
$usearch_bin = "usearch";
$ublast = 1;
$blastreport = "";
$reference = "";
$mode = "m";
$ref_id = 99;

## Read command-line options
for ($i = 0; $i <= scalar(@ARGV); $i++) { # Goes through the list of arguments
  $arg = @ARGV[$i];		# Stores the current argument in $arg

  if ($arg eq "-i") {		# Read input files from -i flag
    $i++;
    $input = @ARGV[$i];
  }
  if ($arg eq "--blastreport") { # Read pre-calculated blast report file from --blastreport flag
    $i++;
    $blastreport = @ARGV[$i];
  }
  if ($arg eq "-o") {		# Read output files from -o flag
    $i++;
    $output = @ARGV[$i];
  }
  if ($arg eq "-d") {		# Read the BLAST database from -d flag
    $i++;
    $blastDB = @ARGV[$i];
  }
  if ($arg eq "--date") { # Determine whether or not to add a date stamp based on the --date flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $out_date = 0;
    } else {
      $out_date = 1;
    }
  }

  if ($arg eq "-t") { # Select what types of rRNAs to look for using the -t flag
    $i++;
    $type = @ARGV[$i];
  }
  if (($arg eq "-g") || ($arg eq "--gene")) { # Read gene from -g (or --gene) flag
    $i++;
    $gene = lc(@ARGV[$i]);
  }
  if ($arg eq "-E") {	    # Set the E-value cutoff using the -E flag
    $i++;
    $E = @ARGV[$i];
  }
  if ($arg eq "-S") {	      # Set the score cutoff using the -S flag
    $i++;
    $S = @ARGV[$i];
  }
  if ($arg eq "-M") { # Set the number of top BLAST matches to consider using the -M flag
    $i++;
    $M = @ARGV[$i];
  }
  if ($arg eq "-H") { # Set the number of points that the HMMER-predicted origin will be given using the -H flag
    $i++;
    $H = @ARGV[$i];
  }
  if ($arg eq "-R") { # Set the taxonomy reliability cutoff using the -R flag
    $i++;
    $C = @ARGV[$i];
  }
  if ($arg eq "-T") { # Set the taxonomy identity cutoff vector using the -T flag
    $i++;
    $T = @ARGV[$i];
  }
  if ($arg eq "--blast_eval") {	# Set the E-value cutoff for the BLAST search using the --blast_eval flag
    $i++;
    $blast_eval = @ARGV[$i];
    $blast_score = "";		#  Turns off score cutoff
  }
  if ($arg eq "--blast_score") { # Set the score cutoff for the BLAST search using the --blast_score flag
    $i++;
    $blast_score = @ARGV[$i];
    $blast_eval = "";		#  Turns off E-value cutoff
  }
  if ($arg eq "--blast_wordsize") { # Set the word size for the BLAST search using the --blast_wordsize flag
    $i++;
    $W = @ARGV[$i];
  }
  if ($arg eq "--cpu") { # Set the number of CPUs to use based on the --cpu flag
    $i++;
    $cpu = @ARGV[$i];
  }
  if ($arg eq "--megablast") { # Determine whether or not to use megablast based on the --megablast flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $megablast = "T";
    } else {
      $megablast = "F";
    }
  }
  if ($arg eq "--plus") {	# Set the blast engine
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Ff0]/) { # Check if argument begins with "F", "f", or "0"
      $plus = 0;
    } else {
      $plus = 1;
    }
  }
  if ($arg eq "--mode") { # Set the operating mode based on the --mode flag
    $i++;
    $mode = lc(substr(@ARGV[$i],0,1));
  }

  if ($arg eq "--scoring_model") { # Determine whether or not to use the 2.2 scoring model
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Oo]/) { # Check if argument begins with "O", "o"
      $scoring_model = "old";
    } else {
      $scoring_model = "new";
    }
  }

  if ($arg eq "--usearch") { # Enable use of usearch based on the --usearch flag
    $i++;
    $usearch = int(@ARGV[$i]);
  }
  if ($arg eq "--usearch_bin") { # Select usearch binary based on the --usearch_bin flag
    $i++;
    $usearch_bin = @ARGV[$i];
  }
  if ($arg eq "--ublast") {   # Determine whether or not to use Ublast
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $ublast = 1;
    } else {
      $ublast = 0;
    }
  }

  if ($arg eq "--reference") { # Select a reference file using the --reference flag
    $i++;
    $reference = @ARGV[$i];
  }
  if ($arg eq "--ref_identity") { # Set the reference identity cutoff using the --ref_identity flag
    $i++;
    $ref_id = @ARGV[$i];
  }


  if ($arg eq "--summary") { # Determine whether or not to output a summary based on the --summary flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $out_sum = 1;
    } else {
      $out_sum = 0;
    }
  }
  if ($arg eq "--fasta") { # Determine whether or not to output FASTA-files based on the --fasta flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $out_fasta = 1;
    } else {
      $out_fasta = 0;
    }
  }
  if ($arg eq "--split_pairs") { # Determine whether or not to split paired output FASTA based on the --split_pairs flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $split_pairs = 1;
    } else {
      $split_pairs = 0;
    }
  }
  if ($arg eq "--taxonomy") { # Determine whether or not to output tables of taxonomic preditions based on the --taxonomy flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $out_tax = 1;
    } else {
      if ((@ARGV[$i] eq "complete") || (@ARGV[$i] eq "2")) { # Check for complete taxonomy
	$out_tax = 2;
      } else {
	$out_tax = 0;
      }
    }
  }
  if ($arg eq "--reltax") { # Determine whether or not to output taxonomy with reliability scores the --reltax flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $out_reltax = 1;
    } else {
      $out_reltax = 0;
    }
  }
  if ($arg eq "--taxlevel") { # Set the forced taxonomy classification level
    $i++;
    $tax_level = @ARGV[$i];
  }


  if ($arg eq "--table") { # Determine whether or not to output tables of all potential matches based on the --table flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $out_table = 1;
    } else {
      $out_table = 0;
    }
  }
  if ($arg eq "--not_found") { # Determine whether or not to output a list of sequences that are not rRNAs based on the --not_found flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $out_not = 1;
    } else {
      $out_not = 0;
    }
  }
  if ($arg eq "--align") { # Determine for what sequences alignments should be made based on the --align flag
    $i++;
    $out_align = substr(@ARGV[$i],0,1);
  }
  if ($arg eq "--guess_species") { # Determine whether or not to guess species based on the --guess_species flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $guess_species = 1;
    } else {
      $guess_species = 0;
    }
  }
  if ($arg eq "--silent") { # Determine whether or not to output anything to the screen based on the --silent flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $silent = 1;
    } else {
      $silent = 0;
    }
  }
  if ($arg eq "--save_raw") { # Determine whether or not to save all the raw intermediate data based on the --save_raw flag
    $i++;
    if (substr(@ARGV[$i],0,1) =~ m/^[Tt1]/) { # Check if argument begins with "T", "t", or "1"
      $save_raw = 1;
    } else {
      $save_raw = 0;
    }
  }

  ## If "-h" or "--help" are among the options, output usage data and options
  if (($arg eq "-h") || ($arg eq "--help")) {
    print "Usage: metaxa2_c -i <input file> -o <output file>\nOptions:$options";
    print "-----------------------------------------------------------------\n";
    exit;			# Exit Metaxa
  }
  ## If "--bugs" is among the options, output bugs and features information
  if ($arg eq "--bugs") {
    print "$bugs\n";
    exit;
  }

  ## If "--license" is among the options, output license information
  if ($arg eq "--license") {
    print "$license\n";
    exit;			# Exit Metaxa
  }

  if ($arg eq "--debug") {	# Run Metaxa in debug mode
    $debug = 1;
  }
  if ($arg eq "--pipeline") {   # Run Metaxa in pipeline mode
    $pipeline = 1;
  }
}

## Setup some variables dependent on input

if ($H < 0) { # If a number of points for the best HMMER guess is not supplied
  $H = $M; # Then set that number of points to the number of top BLAST sequences to investigate
}


$gene = uc($gene);

if ($blastDB eq "") {		# If no blast DB has been specified
  $blastDB = "$bindir\metaxa2_db/$gene/blast"; # Set the blast DB to the gene path
}

## Check for binaries

if ($plus == 1) {
  chomp($path = `which blastn`); # Get the path for blastn
  if ($path eq "") {		 # If the path is empty
    $plus = 0;
    chomp($path = `which blastall`); # Get the path for blastall
  }
} else {
  chomp($path = `which blastall`); # Get the path for blastall
  if ($path eq "") {		   # If the path is empty
    $plus = 1;
    chomp($path = `which blastn`); # Get the path for blastn
  }
}
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate BLAST binaries! It seems that blastall or blastn is not installed properly.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa will now abort.\
If you want to only use the HMMER-based extraction capabilities, use the metaxa_x program.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

if ($plus == 1) {
  chomp($path = `which blastdbcmd`); # Get the path for blastdbcmd
} else {
  chomp($path = `which fastacmd`); # Get the path for fastacmd
}
if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: Could not locate BLAST binaries! It seems that fastacmd or blastdbcmd is not installed properly.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa will now abort.\
If you want to only use the HMMER-based extraction capabilities, use the metaxa_x program.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

chomp($path = `which mafft`);   # Get the path for mafft
if ($path eq "") {  # If the path is empty, then show an error message
  print STDERR "ERROR :: Could not locate MAFFT binaries! Maybe MAFFT is not installed properly?\
Consult the manual for installation instructions.\
This error is not fatal, but will prevent Metaxa from automatically creating alignments.\
Automatic sequence alignment has now been turned off completely.\n";
  print STDERR "-----------------------------------------------------------------\n";
  $out_align = "n";		# Turn off automatic sequence aligning
}

if ($usearch > 0) {
  chomp($path = `which $usearch_bin`); # Get the path for usearch
  if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
    print STDERR "ERROR :: Specified usearch binary could not be found ($usearch_bin)!\
Metaxa will proceed using BLAST instead of Usearch.\n";
    print STDERR "-----------------------------------------------------------------\n";
    $usearch = 0;
  }
}

## Check for databases

chomp($errormsg = `ls $blastDB* 2>&1 1>/dev/null`); # Get the error msg when looking for the BLAST database
if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
  print STDERR "FATAL ERROR :: The specified classification database ($blastDB) could not be found.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa will now abort.\
If you want to only use the HMMER-based extraction capabilities, use the metaxa_x program.\n";
  print STDERR "-----------------------------------------------------------------\n";
  exit;
}

if ($pipeline == 0) { # If metaxa_c is not run in pipeline mode (i.e. from metaxa)
  if ($out_date == 1) {	 # If a date and time stamp should be supplied
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time); # Get the date and time
    $year = $year + 1900;	# Format the year
    $mon = $mon + 1;		# Format the month
    if ($mon < 10) {		# Add a zero to the month, if needed
      $mon = "0" . $mon;
    }
    if ($mday < 10) {		# Add a zero to the day, if needed
      $mday = "0" . $mday;
    }
    if ($hour < 10) {		# Add a zero to the hour, if needed
      $hour = "0" . $hour;
    }
    if ($min < 10) {		# Add a zero to the minute, if needed
      $min = "0" . $min;
    }
    $outputDate = ".$year\-$mon\-$mday\_$hour.$min"; # Create a date and time stamp
    $outputDate =~ s./.-.g; # Remove any potential slashes in the output name (as this will confuse Metaxa's file naming)
    $output = $output . $outputDate; # Add the date and time stamp top the output base name
  }
}

$tempDir = "metaxa_temp_directory__$output"; # Setup a temporary directory variable
$tempDir =~ s./.-.g; # Remove any potential slashes in the output name (as this will confuse Metaxa's file naming)

if ($guess_species != 0) {    # Warn if --guess_species option is used
  print STDERR "WARNING :: The --guess_species option has been depreciated as of Metaxa2!\n";
  print STDERR "           The option remains for backwards-compatibility, but for taxonomic analysis,\n";
  print STDERR "           the --taxonomy option should be used instead.\n";
}

if ($pipeline == 0) {		# If not running in pipeline mode
  ## Create a summary file
  if ($out_sum == 1) {			    # If summary output is on
    $now = localtime;			    # Get the current time
    open (SUMMARY, ">$output.summary.txt"); # Create the summary file
    print SUMMARY "Metaxa2_c run started at $now.\n"; # Output the starting time for the analysis
    print SUMMARY "-----------------------------------------------------------------\n";
    close (SUMMARY);		# Close summary file
  }
}

## Create a temporary directory for Metaxa
if ($pipeline == 0) { # If metaxa_c is not run in pipeline mode (i.e. from metaxa)
  `mkdir $tempDir 2> /dev/null`; # Create a temporary directory
}

## Setup MAFFT-output directory (if needed)
if ($out_align ne "n") { # If not alignment output is completely turned off
  `mkdir $output\_alignments 2> /dev/null`; # Create an alignment output directory
}

## Open the summary file for writing
if ($out_sum == 1) {			   # If summary output is on
  open (SUMMARY, ">>$output.summary.txt"); # Append to the summary file
}

if ($T eq "default") { # If database default values should be used for the taxonomy cutoffs
  ## Read cutoffs from database
  open (CUTS, "$blastDB.cutoffs.txt"); # Open the cutoffs file
  $line = <CUTS>;
  chomp($line);
  $T = $line;			# Save the cutoffs as the T vector
  close CUTS;			# Close cutoffs database file
}

## Prepare the taxonomy cutoff vector
@T = split(',',$T);		# Spilt T string into array
$lenT = scalar(@T) - 1;
$lastT = @T[$lenT];
for ($i = $lenT; $i <= 10; $i++) {
  @T[$i] = $lastT;
}
unshift(@T, 0);

## Prepare profile set data etc.  ## THIS CODE MAY HAVE A PROBLEM IN VERSION 2.2!
@profileList = split(',',$type); # Get the list of profile types
foreach $entry (@profileList) {	 # Go through the entered types
  if (($entry eq "all") || ($entry eq "A")) { # If "all" or "A" is among the entries
    push(@profileSet,"A"); # Add the archaea profiles to the investigation set
    push(@profileSet,"B"); # Add the bacteria profiles to the investigation set
    push(@profileSet,"C"); # Add the chloroplast profiles to the investigation set
    push(@profileSet,"E"); # Add the eukaryota profiles to the investigation set
    push(@profileSet,"M"); # Add the mitochondrial 16S profiles to the investigation set
    if ($gene ne "5S") {
      push(@profileSet,"N"); # Add the mitochondrial 12S profiles to the investigation set
    }
  }
  ##Archaea
  if ((substr($entry,0,1) eq "a") && ($entry ne "all")) { # If the first charachter of the entry is "a", but the complete entry not is "all"
    push(@profileSet,"A"); # Add the archaea profiles to the investigation set
  }
  ## Bacteria
  if (substr($entry,0,1) eq "b") { # If the first charachter of the entry is "b"
    push(@profileSet,"B"); # Add the bacteria profiles to the investigation set
  }
  ## Eukaryota
  if (substr($entry,0,1) eq "e") { # If the first charachter of the entry is "e"
    push(@profileSet,"E"); # Add the eukaryota profiles to the investigation set
  }
  ## Chloroplasts
  if (substr($entry,0,1) eq "c") { # If the first charachter of the entry is "c"
    push(@profileSet,"C"); # Add the chloroplast profiles to the investigation set
  }
  ## Mitochondria
  if (substr($entry,0,1) eq "m") { # If the first charachter of the entry is "m"
    push(@profileSet,"M"); # Add the mitochondrial 16S profiles to the investigation set
    if ($gene ne "5s") {
      push(@profileSet,"N"); # Add the mitochondrial 12S profiles to the investigation set
    }
  }
  ## Other (this is an 'undocumented' feature)
  if (substr($entry,0,1) eq "o") { # If the first charachter of the entry is "o"
    push(@profileSet,"O"); # Add a potential set of 'other' (custom) profiles to the investigation set
  }
}

## Prepare reference sequences
if ($reference ne "") {
  chomp($errormsg = `ls $reference 2>&1 1>/dev/null`); # Get the error msg when looking for the BLAST database
  if (substr($errormsg,0,4) eq "ls: ") { # If the error message begins with "ls: ", then show an error message and exit Metaxa
    print STDERR "FATAL ERROR :: The specified reference sequences ($reference) could not be found.\
This error is fatal, and Metaxa will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }

  if ($plus == 1) {
    chomp($path = `which makeblastdb`);	# Get the path for blastdbcmd
  } else {
    chomp($path = `which formatdb`); # Get the path for fastacmd
  }
  if ($path eq "") { # If the path is empty, then show an error message and exit Metaxa
    print STDERR "FATAL ERROR :: Could not locate BLAST binaries! It seems that formatdb or makeblastdb is not installed properly.\
Consult the manual for installation instructions.\
This error is fatal, and Metaxa will now abort.\n";
    print STDERR "-----------------------------------------------------------------\n";
    exit;
  }

  if ($plus != 1) {
    `formatdb -t "Metaxa2 reference database" -i $reference -n $tempDir/REF_DB -p F -o F`;
  } else {
    `makeblastdb -title "Metaxa2 reference database" -in $reference -out $tempDir/REF_DB -dbtype nucl`;
  }
}

## Get the total memory available
open (MEMFILE, "/proc/meminfo");  #  Open the memory information "file"
while (chomp($line = <MEMFILE>)) {  # Read from this file
  if (substr($line, 0, 9) eq "MemTotal:") {  # If this is the total memoryline
    $line =~ s/  */ /g;  # Remove extra spaces
    ($blah,$memtotal,$kblah) = split(' ',$line);  # Extract total memory value
    if ($kblah eq "kB") {  # If value given in kilobytes
      $memtotal = $memtotal * 1024;  # Convert memory value to bytes
    }
    if ($kblah eq "MB") {  # If value given in megabytes
      $memtotal = $memtotal * 1024 * 1024;  # Convert memory value to bytes
    }
    if ($kblah eq "GB") {  # If value given in gigabytes
      $memtotal = $memtotal * 1024 * 1024 * 1024;  # Convert memory value to bytes
    }
    if ($kblah eq "TB") {  # If value given in terabytes
      $memtotal = $memtotal * 1024 * 1024 * 1024 * 1024;  # Convert memory value to bytes
    }
  }
}
close (MEMFILE);  # Close memory file

$curmem = 0;  # Reset the memory tracker
$filenumber = 1;  # Reset the file number counter
$no_of_seqs = `grep -c ">" $input`;  # Count sequences in input file
if ($memtotal == 0) {  # If the total memory could not be determined for some reason
  #$memtotal = 1024 * 1024 * 1024;  # Reserve 1GB of RAM, who does not have that??
  $memtotal = 1024 * 1024 * 1024;  # Reserve 1GB of RAM, who does not have that??
}

$seqPerFile = int($memtotal / 10000);
## Split the input file
open (SEQUENCES, $input);   # Open the input sequence file for reading
open (SPLITFILE, ">$input.$filenumber");   # Open the first split sequence file for writing
while ($line = <SEQUENCES>) { # Read the file line by line
  if (substr($line,0,1) eq ">") {    # Id this is a seq ID
    $seqCount++;
    if ($seqCount > $seqPerFile) {
      close SPLITFILE;
      $filenumber++;
      open (SPLITFILE, ">$input.$filenumber");   # Open a new split sequence file for writing
      $seqCount = 1;
    }
  }
  print SPLITFILE $line;  # Print this line to the split file
}
close SEQUENCES;		#   Close the sequence input file
close SPLITFILE;		#   Close the last split sequence file

$totalfiles = $filenumber;

for ($filenumber = 1; $filenumber <= $totalfiles; $filenumber++) {
  if ($totalfiles > 1) {
    $now = localtime;
    if ($silent == 0) {
      print STDERR "$now : Now running classification for batch $filenumber of $totalfiles...\n";
    }
  }
  if ($blastreport eq "") {
    if (($usearch > 0) && ($usearch < 4)) {
      print STDERR "Usearch version 4.0 or later required! Will continue using BLAST instead.\n";
      $usearch = 0;
    }
    if ($usearch > 7) {
      print STDERR "Usearch version 7.0 or earlier expected! Metaxa2 will try to use the usearch 7.0 syntax for classification.\n";
      $usearch = 7;
    }
    if ($usearch == 0) {
      ## Perform BLAST search
      ## Get the current time and output info message
      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : Comparing sequences to classification database using BLAST (this may take a long while)...\n";
      }
      if ($plus == 1) { 
	if ($megablast eq "T") {
	  `blastn -db $blastDB -query $input.$filenumber -evalue $blast_eval -outfmt 6 -out $tempDir/rRNA.blastn.$filenumber -dust no -max_target_seqs $M -num_threads $cpu -word_size $W -task megablast`; # Start the BLAST search and wait for it to finish
	} else {
	  `blastn -db $blastDB -query $input.$filenumber -evalue $blast_eval -outfmt 6 -out $tempDir/rRNA.blastn.$filenumber -dust no -max_target_seqs $M -num_threads $cpu -word_size $W`; # Start the BLAST search and wait for it to finish
	}
      } else {
	`blastall -p blastn -d $blastDB -i $input.$filenumber -e $blast_eval -m 8 -o $tempDir/rRNA.blastn.$filenumber -F F -v $M -b $M -a $cpu -W $W -n $megablast`; # Start the BLAST search and wait for it to finish
      }
    } else {
      ## Perform Usearch search
      ## Get the current time and output info message
      $now = localtime;
      if ($silent == 0) {
	print STDERR "$now : Comparing sequences to classification database using Usearch (this may take a long while)...\n";
      }
      
      if ($usearch == 8) {
	if ($ublast == 1) {
	  `$usearch_bin -ublast $input.$filenumber -db $blastDB.fasta -evalue $blast_eval -accel 0.5 -blast6out $tempDir/rRNA.blastn.$filenumber -qmask none -dbmask none -strand both -threads $cpu -maxhits $M -maxaccepts 0 --quiet`;
	} else {
	  `$usearch_bin -usearch_local $input.$filenumber -db $blastDB.fasta -id 0.5 -evalue $blast_eval -blast6out $tempDir/rRNA.blastn.$filenumber -qmask none -dbmask none -strand both -threads $cpu -maxhits $M -maxaccepts 0 --quiet`;
	}
      }
      if ($usearch == 7) {
	if ($ublast == 1) {
	  `$usearch_bin -ublast $input.$filenumber -db $blastDB.fasta -evalue $blast_eval -accel 0.5 -blast6out $tempDir/rRNA.blastn.$filenumber -qmask none -dbmask none -strand both -threads $cpu -maxhits $M -maxaccepts 0 --quiet`;
	  
	} else {
	  `$usearch_bin -usearch_local $input.$filenumber -db $blastDB.fasta -id 0.5 -evalue $blast_eval -blast6out $tempDir/rRNA.blastn.$filenumber -qmask none -dbmask none -strand both -threads $cpu -maxhits $M -maxaccepts 0 --quiet`;
	}
      }
      if ($usearch == 6) {
	if ($ublast == 1) {
	  `$usearch_bin -ublast $input.$filenumber -db $blastDB.fasta -evalue $blast_eval -accel 0.5 -blast6out $tempDir/rRNA.blastn.$filenumber -qmask none -dbmask none -strand both -threads $cpu -maxhits $M -maxaccepts 0 --quiet`;
	} else {
	  `$usearch_bin -usearch_local $input.$filenumber -db $blastDB.fasta -id 0.5 -evalue $blast_eval -blast6out $tempDir/rRNA.blastn.$filenumber -qmask none -dbmask none -strand both -threads $cpu -maxhits $M -maxaccepts 0 --quiet`;
	}
      }
      
      if ($usearch == 5) {
	`$usearch_bin --query $input.$filenumber --db $blastDB.fasta --evalue $blast_eval --blast6out $tempDir/rRNA.blastn.$filenumber --rev --maxaccepts $M --quiet`;
      }
      if ($usearch == 4) {
	`$usearch_bin --query $input.$filenumber --db $blastDB.fasta --evalue $blast_eval --blast6out $tempDir/rRNA.blastn.$filenumber --rev --maxaccepts $M --quiet`;
      }
    }
    
    if ($reference ne "") {
      ## Perform BLAST search against reference database
      if ($plus == 1) { 
	if ($megablast eq "T") {
	  `blastn -db $tempDir/REF_DB -query $input.$filenumber -evalue $blast_eval -outfmt 6 -out $tempDir/reference.blastn.$filenumber -dust no -max_target_seqs $M -num_threads $cpu -word_size $W -task megablast`; # Start the BLAST search and wait for it to finish
	} else {
	  `blastn -db $tempDir/REF_DB -query $input.$filenumber -evalue $blast_eval -outfmt 6 -out $tempDir/reference.blastn.$filenumber -dust no -max_target_seqs $M -num_threads $cpu -word_size $W`; # Start the BLAST search and wait for it to finish
	}
      } else {
	`blastall -p blastn -d $tempDir/REF_DB -i $input.$filenumber -e $blast_eval -m 8 -o $tempDir/reference.blastn.$filenumber -F F -v $M -b $M -a $cpu -W $W -n $megablast`; # Start the BLAST search and wait for it to finish
      }
    }
  } else {
    `cp $blastreport $tempDir/rRNA.blastn.$filenumber`;
  }

  open (BLASTOUT, ">>$tempDir/rRNA.blastn.$filenumber"); # Open the BLAST output file for writing
  print BLASTOUT "END\n";			   # Print an end line
  close BLASTOUT;				   # Close BLAST output file
  
  if ($reference ne "") {
    open (BLASTOUT, ">>$tempDir/reference.blastn.$filenumber"); # Open the reference BLAST output file for writing
    print BLASTOUT "END\n";			  # Print an end line
    close BLASTOUT;		# Close BLAST output file
  }
  
  ## Analyse BLAST output
  ## Get the current time and output info
  $now = localtime;
  if ($silent == 0) {
    print STDERR "$now : Analysing classification results (this might take quite some time)...\n";
  }


  ## Read taxonomy from database
  open (TAXDB, "$blastDB.taxonomy.txt"); # Open the taxonomy file
  while ($line = <TAXDB>) {	       # Read taxonomy db file
    chomp($line);
    ($id,$tax) = split('\t',$line); # Separate each line into identifier and taxonomy
    ($realtax,$nottax) = split('\(',$tax); # Remove everything after a parenthesis in the taxonomy data
    $taxonomy{$id} = $realtax;	# Add taxonomy to the loaded database
  }
  close TAXDB;			# Close taxonomy database file
  
  ## Set up output files
  if ($filenumber == 1) {
    if ($out_table == 1) {			# If table output is on
      open (TABLE, ">$output.blast.table");	# Create a table output file
    }
    if ($out_fasta == 1) {			   # If FASTA output is on
      open (AFASTA, ">$output.archaea.fasta"); # Create the archaea FASTA file
      open (BFASTA, ">$output.bacteria.fasta"); # Create the bacteria FASTA file
      open (EFASTA, ">$output.eukaryota.fasta"); # Create the eukaryote FASTA file
      open (MFASTA, ">$output.mitochondria.fasta");	# Create the mitochondrial FASTA file
      open (CFASTA, ">$output.chloroplast.fasta"); # Create the chloroplast FASTA file
      open (UFASTA, ">$output.uncertain.fasta"); # Create the uncertain FASTA file
    }
    if ($out_not == 1) {		# If not-found output is on
      open (NOTFOUND, ">$tempDir/rRNA_blast_not_found.txt"); # Create a BLAST not-found output file
    }
    
    if ($out_tax > 0) {			    # If taxonomy output is on
      open (TAXONOMY, ">$output.taxonomy.txt"); # Create a taxonomy table output file
    }
    if ($out_reltax > 0) {		# If taxonomy output is on
      open (RELTAX, ">$output.taxonomy-reliability.txt"); # Create a taxonomy table output file
    }

    open (RAWOUT, ">$tempDir/$output.classification.raw"); # Create a raw classification output file
  }
  
  undef %sequences;
  undef %inputList;
  ## Read the input sequences
  open (SEQUENCES, "$input.$filenumber");   # Open the input sequence file for reading
  while (chomp($line = <SEQUENCES>)) { # Read the file line by line
    if (substr($line,0,1) eq ">") {    # Id this is a seq ID
      ($seqID) = split(' ',$line); # Get the first word of this line (before the first space), should be the sequence ID
      $seqID = substr($seqID,1); # Remove the ">" character from the seq ID
      $DNA = "";		       # Empty the DNA sequence
    } else {
      $DNA = $DNA . $line;       # Add the next line to the DNA sequence
      $sequences{$seqID} = $DNA; # Add this DNA sequence
      $inputList{$seqID} = 1;    # Make a list of input IDs
    }
  }
  close SEQUENCES;		#   Close the sequence input file

  undef %refHits;
  if ($reference ne "") {
    open (REFBLASTOUT, "$tempDir/reference.blastn.$filenumber"); # Open the reference BLAST output file for reading
    if ($filenumber == 1) {
      open (REFFASTA, ">$output.reference.fasta"); # Create the reference FASTA output file
    }
    $ssuREF = 0;
    ## Read and analyse BLAST output file
    while ($line = <REFBLASTOUT>) { # Read in the BLAST output file, line by line
      chomp($line);		  # Remove any potential line feeds

      ($query,$subject,$identity,$length,$mismatches,$gaps,$qs,$qe,$ss,$se,$mEval,$mScore) = split('\t',$line);
      
      if (($identity >= $ref_id) && ($length >= 50)) {
	## Extract the sequence
	$DNA = $sequences{$query};
	if (($length >= length($DNA) * 0.5) || ($qs < 2) || ($qe == length($DNA))) {
	  if (defined($refHits{$query})) {
	    $refHits{$query}++;
	  } else {
	    $ssuREF++;
	    $refHits{$query} = 1;
	  
	    $queryType = substr($query,length($query) - 2, 2); # Use the last two characters of the query identifier to determine the metaxa_x-assigned origin of the sequence
	    if ($queryType =~ m/\|[ABCEFMNO]/) { # If the query type begins with a "|" and ends with any of these characters "ABCEFMNO", then assume that metaxa_x did its job
	      $queryType = substr($queryType,1,1); # Remove the leading "|" from the query type
	      $writeQuery = substr($query,0,length($query) - 2); # Remove the last two characters ("|X") from the query identifier to restore the original query identifier for the output
	    } else { # If the query does not seem to be processed by metaxa_x
	      $writeQuery = $query; # Assure that the output query identifier will be the same as the input identifier
	      $queryType = ""; # Specify that there is no metaxa_x origin data for this sequence
	    }
	    
	    push(@ssuRList,$writeQuery); # Add this entry to the list of reference rRNA sequences
	    print REFFASTA ">$writeQuery Reference rRNA\n"; # Write definition line to the reference FASTA file
	    print REFFASTA "$DNA\n"; # Write the DNA sequence to the archaea FASTA file
	  }
	}
      }
    }
    close REFFASTA;
    close REFBLASTOUT;
  }

  open (BLASTOUT, "$tempDir/rRNA.blastn.$filenumber"); # Open the BLAST output file for reading
  
  if ($filenumber == 1) {
    ## Set all counts for different rRNA types, and found sequences to zero
    $ssuA = 0;
    $ssuB = 0;
    $ssuC = 0;
    $ssuE = 0;
    $ssuM = 0;
    $ssuU = 0;
    $ssuQueries = 0;
    $ssuDB = 0;
  }

  $lastQuery = "";

  ## Read and analyse BLAST output file
  while ($line = <BLASTOUT>) { # Read in the BLAST output file, line by line
    chomp($line);		     # Remove any potential line feeds
    
    #print STDERR $line . "\n";
    
    ($query,$subject,$identity,$length,$mismatches,$gaps,$qs,$qe,$ss,$se,$mEval,$mScore) = split('\t',$line);
    
    $query =~ s/ .*//;
    $subject =~ s/ .*//;
    $subject =~ s/^lcl.//;
    
    $line = $query . "\t" . $subject . "\t" . $identity . "\t" . $length . "\t" . $mismatches . "\t" . $gaps . "\t" . $qs . "\t" . $qe . "\t" . $ss . "\t" . $se . "\t" . $mEval . "\t" . $mScore;

    if ($out_table == 1) {	# If table output is on
      if ($line ne "END") {
	print TABLE $line . "\n";	# Print to blast table output
      }
    }

    if (defined($refHits{$query})) {
      next;
    }

    $saveData = 0; # Make sure this line does not get saved automatically
    if ($query ne $lastQuery) { # If the query ID is not the same as the last one, this is a new query
      if ($lastQuery ne "") {
	$saveData = 1;		# Indicate that data should be saved
      }
    }
    if ($line eq "END") {
      $saveData = 1;
    }
  
    if ($saveData == 1) {		   # If data should be saved
      if (scalar(@matchArray) > 0) { # If there is matches
	## We first need to sort the matches by total score, since BLAST stupidly sorts them by their best domain...
	undef %scoreNum;
	undef @unsortedMatchArray;
	for ($matchCountDown = $M; $matchCountDown > 0; $matchCountDown--) { # Go through match list
	  ($matchQuery,$matchSubject,$matchIdentity,$matchLength,$matchMismatches,$matchGaps,$matchEval,$matchScore,$matchCounts) = split('\t', @matchArray[$matchCountDown]); # Get data for this match
	  $scoreNum{$matchCountDown} = $matchScore; # Set up a score hash
	  @unsortedMatchArray[$matchCountDown] = @matchArray[$matchCountDown];
	}
	$matchCountDown = $M;
	foreach $key (sort { $scoreNum{$b} <=> $scoreNum{$a} } keys(%scoreNum) ) { # Sort the score hash by score
	  @matchArray[$matchCountDown] = @unsortedMatchArray[$key]; # Create a new match array ordered by total score
	  $matchCountDown--;
	}
	undef @taxonomies;	# Empty the taxonomy data array
	for ($matchCountDown = $M; $matchCountDown > 0; $matchCountDown--) {
	  if (@matchArray[$matchCountDown] eq "") {
	    next;
	  }
	  ($matchQuery,$matchSubject,$matchIdentity,$matchLength,$matchMismatches,$matchGaps,$matchEval,$matchScore,$matchCounts) = split('\t', @matchArray[$matchCountDown]); # Get data for this match

	  $matchIdentity = $matchIdentity / $matchCounts;	# Calculate average identity
	  $matchEval = $matchEval / $matchCounts;	# Calculate average E-value
	  $matchTaxonomy = $taxonomy{$matchSubject}; # Get taxonomy for blast match
	  if ($matchTaxonomy eq "") {
	    print STDERR "FATAL ERROR! Taxonomy database is corrupted.\n$matchSubject not present in taxonomy database. The Metaxa2 classifier must now abort.\n";
	    exit;
	  }
	  @matchTaxonomy = split(';',$matchTaxonomy); # Create an array for the taxonomy data
	  $matchSpecies = @matchTaxonomy[-1]; # The last item of the taxonomy data should be the species (for backwards-compatibility)
	  if ($matchEval <= $E) {	# If the E-value of this match is smaller than the E-value cutoff
	    $matchType = substr($matchSubject,length($matchSubject) - 1, 1); # Extract the rRNA type from the match identifier, by cutting out the last character (all sequences in the database should end with ".X" specifying the type)
	    push(@hits,$matchType . "\t" . $matchCountDown . "\t" . $matchSpecies . "\t" . $matchScore . "\t" . $matchEval); # Add this match to the list of hits
	    push(@taxonomies,$matchTaxonomy . "\t" . $matchIdentity . "\t" . $matchLength); # Add this match to the list of taxonomy data
	    if (exists($inputList{$matchQuery})) {
	      delete $inputList{$matchQuery}; # Remove this item from the input list
	    }
	    
	    ## Add the maximal number of points to the top match, one less point to the second, and so on...
	    if ($matchType eq "A") { # If this BLAST-hit is archaeal, add X to the A-type
	      $Atype = $Atype + $matchCountDown;
	    }
	    if ($matchType eq "B") { # If this BLAST-hit is bacterial, add X to the B-type
	      $Btype = $Btype + $matchCountDown;
	    }
	    if ($matchType eq "E") { # If this BLAST-hit is eukaryote, add X to the E-type
	      $Etype = $Etype + $matchCountDown;
	    }
	    if ($matchType eq "C") { # If this BLAST-hit is chloroplastic, add X to the C-type
	      $Ctype = $Ctype + $matchCountDown;
	    }
	    if ($matchType eq "M") { # If this BLAST-hit is mitochondrial 16S, add X to the M-type
	      $Mtype = $Mtype + $matchCountDown;
	    }
	    if ($matchType eq "N") { # If this BLAST-hit is mitochondrial 12S, add X to the N-type
	      $Ntype = $Ntype + $matchCountDown;
	    }
	    
	    ## Get sequence of the hit from the metaxa BLAST database...
	    if ($out_align ne "n") { # If alignments should be calculated for at least some sequences
	      if ($plus == 1) {
		$matchSeq = `blastdbcmd -entry "$matchID" -db $blastDB  2>> $tempDir/blastdbcmd_error_log.txt`; # Get the sequence of the hit using blastdbcmd
	      } else {
		$matchSeq = `fastacmd -s "$matchID" -d $blastDB  2>> $tempDir/fastacmd_error_log.txt`; # Get the sequence of the hit using fastacmd
	      }
	      push(@matchSeqs,$matchSeq);	# Add the sequence to the list of matched sequences
	    }
	  }
	}
	undef @matchArray;	# Empty the match array


	if ($out_tax > 0) {	# If taxonomy output is on
	  
	  ## Determine taxonomic origin
	  $agreement = "";
	  $bestIdentity = 0;
	  $bestLength = 0;
	  $bestLevels = 1;
	  $confidenceWeight = 1;
	  $confidenceScore = 0;
	  $confidenceDivisor = 0;
	  if ($out_reltax == 1) {
	    print RELTAX $writeQuery . "\t";
	    $reltax_output = "";
	  }
	  if ($out_tax == 2) {	# If complete taxonomy output is on
	    print TAXONOMY " --- " . $writeQuery . " --- " . "\n";
	    for ($t = 0; $t < scalar(@taxonomies); $t++) { # For each hit's taxonomy data (from best to "worst")
	      print TAXONOMY "\t" . @taxonomies[$t] . "\n";
	    }
	  }

	  if ($scoring_model eq "new") {
	    ## Get number of levels of best hit
	    ($tax, $taxIdentity, $taxLength) = split('\t',@taxonomies[0]);
	    $taxA = $tax;
	    $firstlevels = ($taxA =~ tr/;//) + 1;
	    $final_output_level = 0;
	    
	    undef @rScore;
	    ## Go through all levels down to domain
	    for ($current_level = $firstlevels; $current_level > 0; $current_level--) {
	      @rScore[$current_level] = 0;
	      undef @rScore_per_tax;
	      ($tax, $taxIdentity, $taxLength) = split('\t',@taxonomies[0]);
	      @taxA_levels = split(';', $tax);
	      $firsthit_taxa = @taxA_levels[$current_level-1];
	      $valid_entries = 0;
	      for ($t = 0; $t < scalar(@taxonomies); $t++) { # For each hit's taxonomy data (from best to "worst")
		($tax, $taxIdentity, $taxLength) = split('\t',@taxonomies[$t]);
		@taxA_levels = split(';', $tax);
		$thishit_taxa = @taxA_levels[$current_level-1];
		if ($taxIdentity < @T[$current_level]) {
		  $rID = 0;
		} else {
		  $rID = $taxIdentity / 100;
		  $valid_entries++;
		}
		$rLen = $taxLength;
		
		if ($debug == 1) {
		  print STDERR "------------------------------:\n";
		  print STDERR "tax:\t$tax\n";
		  print STDERR "taxIdentity:\t$taxIdentity\n";
		  print STDERR "taxLength:\t$taxLength\n";
		  print STDERR "t:\t$t\n";
		  print STDERR "current_level:\t$current_level\n";
		  print STDERR "T[cl]:\t@T[$current_level]\n";
		  print STDERR "rID:\t$rID\n";
		  print STDERR "rLen:\t$rLen\n";
		}
		
		if ($thishit_taxa ne "") {
		  if ($thishit_taxa eq $firsthit_taxa) {
		    # 1 - 10^-(IDENTITY^2 / (1.0005^(-1*ALN_LENGTH^IDENTITY^1.1)))
		    @rScore_per_tax[$t] = 1 - 10 ** (-1 * ( ($rID ** 2) / (1.0005 ** (-1 * ($rLen ** ($rID ** 1.1) ) ) ) ) );
		  } else {
		    @rScore_per_tax[$t] = 0;
		  }
		} else {
		  @rScore_per_tax[$t] = 0;
		}
	      }
	      $rScore_at_level = 0;
	      for ($t = 0; $t < scalar(@taxonomies); $t++) {
		$rScore_at_level = $rScore_at_level + @rScore_per_tax[$t];
	      }
	      ##PROBLEMATIC LINE
	      if ($valid_entries > 0) {
		$rScore_at_level = ($rScore_at_level / $valid_entries) * 100;
	      } else {
		$rScore_at_level = 0;
	      }
	      
	      $confidence = $rScore_at_level;
	      
	      @rScore[$current_level] = $rScore_at_level;
	      
	      if ($confidence >= $C) {
		if ($final_output_level < $current_level) {
		  $final_output_level = $current_level;
		}
		if ($out_reltax == 0) {
		  last;
		}
	      }
	      
	      if ($current_level <= $tax_level) {
		if ($final_output_level < $current_level) {
		  $final_output_level = $current_level;
		}
		if ($out_reltax == 0) {
		  last;
		}
	      }
	      
	      if ($current_level >= 0) {
		if ($out_reltax == 1) {
		  $reltax_output = $firsthit_taxa . "(" . substr($confidence,0,5) . ");" . $reltax_output;
		}
	      }
	      
	    }
	    
	    if ($out_reltax == 1) {
	      print RELTAX $reltax_output . "\n";
	    }	
	    
	    ## FILL THESE WITH NUMBERS & TAX DATA!
	    ($tax, $taxIdentity, $taxLength) = split('\t',@taxonomies[0]);
	    @taxA_levels = split(';', $tax);
	    $agreement = "";
	    for ($tl = 0; $tl < $final_output_level; $tl++) {
	      $agreement = $agreement . @taxA_levels[$tl] . ";";
	    }
	    $confidence = @rScore[$final_output_level];
	    $bestLevels = scalar(@taxA_levels);
	    $bestIdentity = $taxIdentity;
	    $bestLength = $taxLength;
	    
	    print TAXONOMY $writeQuery . "\t" . $agreement . "\t" . substr($bestIdentity,0,5) . "\t" . $bestLength . "\t" . substr($confidence,0,5) . "\n"; # Print taxonomic prediction
	    
	  }
	  
	  
	  if ($scoring_model eq "old") {
	    ## CONFIDENCE CODE
	    $foundFinal = 0;
	    while (($bestLevels > 1) || ($agreement eq "")) {
	      for ($t = 0; $t < scalar(@taxonomies); $t++) { # For each hit's taxonomy data (from best to "worst")
		($tax, $taxIdentity, $taxLength) = split('\t',@taxonomies[$t]); # Split up the taxonomy data for this entry
		
		if ($agreement eq "") { # If this is the first entry
		  $taxA = $tax;
		  $firstlevels = ($taxA =~ tr/;//) + 1;
		  $current_level = $firstlevels;
		  $first_tax = $tax;
		  while ($taxIdentity < @T[$firstlevels]) {
		    $taxA =~ s/;[^;]*$//;
		    $firstlevels = ($taxA =~ tr/;//) + 1;
		  }
		  
		  $agreement = $taxA;
		  $lastAgreement = $agreement;
		  $bestIdentity = $taxIdentity;
		  $bestLength = $taxLength;
		  $bestLevels = ($taxA =~ tr/;//) + 1;
		  $confidenceWeight = 1;
		  $confidenceScore = $bestLevels;
		  $confidenceDivisor = $bestLevels;
		  
		  ## NEW CODE... ##
		  $preserveTax = $lastAgreement;
		  while (($preserveTax =~ tr/;//) + 1 > $tax_level) {
		    $preserveTax =~ s/;[^;]*$//;
		    if ($tax_level <= 1) {
		      last;
		    }
		  }
		  ## END OF NEW CODE
		  next;
		}
		if ($taxIdentity < @T[$bestLevels]) {
		  next;
		}
		$taxA = $tax;
		
		if ($agreement =~ m/$taxA/) {
		  $levels = ($taxA =~ tr/;//) + 1;
		} else {
		  while ($agreement !~ m/$taxA/) {
		    if ($taxA !~ m/;/) {
		      last;
		    }
		    if (($taxA =~ tr/;//) + 1 == $tax_level) {
		      $preserveTax = $lastAgreement;
		      while (($preserveTax =~ tr/;//) + 1 > $tax_level) {
			$preserveTax =~ s/;[^;]*$//;
		      }
		    }
		    $taxA =~ s/;[^;]*$//;
		  }
		  $levels = ($taxA =~ tr/;//) + 1;
		}
		
		
		if ($agreement eq $taxA) {
		  $weight = ($taxIdentity / 100) / (($bestIdentity * ($bestLength * 1.0005 ** (-1 * $bestLength))) / ($taxIdentity * ($bestLength * 1.0005 ** (-1 * $bestLength))));
		} else {
		  $weight = ($taxIdentity / 100) / (($bestIdentity * ($bestLength * 1.0005 ** (-1 * $bestLength))) / ($taxIdentity * ($taxLength * 1.0005 ** (-1 * $taxLength))));
		}
		if ($weight > 1) {
		  $weight = 1;
		}
		$oldWeight = $confidenceWeight;
		$confidenceWeight = $confidenceWeight + $weight;
		
		if ($levels * $confidenceWeight >= $confidenceScore) {
		  $agreement = $taxA;
		  $confidenceScore = $confidenceWeight * $levels;
		  $confidenceDivisor = $confidenceDivisor + $bestLevels;
		} else {
		  $confidenceWeight = $oldWeight;
		  if ($levels < $bestLevels) {
		    $confidenceDivisor = $confidenceDivisor + ($bestLevels - $levels) * $weight;
		  }
		}
		
	      }
	      
	      if ($confidenceDivisor > 0) {
		$confidence = (($confidenceScore) / $confidenceDivisor) * 100;
	      } else {
		$confidence = $confidenceScore * 100;
	      }
	      
	      $current_level--;
	      if ($out_reltax == 1) {
		@divided_tax = split(';',$first_tax);
		$tax_at_this_level = @divided_tax[($current_level-1)];
		if ($tax_at_this_level ne "") {
		  $reltax_output = $tax_at_this_level . "(" . substr($confidence,0,5) . ");" . $reltax_output;
		}
	      }
	      
	      if ($confidence >= $C) {
		if ($out_reltax == 0) {
		  last;
		} else {
		  if ($foundFinal == 0) {
		    $foundFinal = 1;
		    $final_confidence = $confidence;
		    $final_agreement = $agreement;
		    $final_bestLevels = $bestLevels;
		    $final_bestIdentity = $bestIdentity;
		    $final_bestLength = $bestLength;
		  }
		}
	      }
	    
	      if ($levels <= $tax_level) {
		$agreement = $preserveTax;
		if ($out_reltax == 0) {
		  last;
		} else {
		  if ($foundFinal == 0) {
		    $foundFinal = 1;
		    $final_confidence = $confidence;
		    $final_agreement = $agreement;
		    $final_bestLevels = $bestLevels;
		    $final_bestIdentity = $bestIdentity;
		    $final_bestLength = $bestLength;
		  }
		}
	      }
	      if ($lastAgreement eq $agreement) {
		$agreement =~ s/;[^;]*$//;
	      }
	      
	      $lastAgreement = $agreement;
	      $bestLevels = ($agreement =~ tr/;//) + 1;
	      
	      $confidenceWeight = 0;
	      $confidenceScore = 0;
	      $confidenceDivisor = 0;
	      
	      if ($bestLevels == 1) {
		$current_level--;
		if ($current_level > 0) {
		  if ($out_reltax == 1) {
		    @divided_tax = split(';',$first_tax);
		    $tax_at_this_level = @divided_tax[($current_level-1)];
		    $reltax_output = $tax_at_this_level . "(" . substr($confidence,0,5) . ");" . $reltax_output;
		  }
		}
		last;
	      }
	      
	    }
	  
	    if ($out_reltax == 1) {
	      $confidence = $final_confidence;
	      $agreement = $final_agreement;
	      $bestLevels = $final_bestLevels;
	      $bestIdentity = $final_bestIdentity;
	      $bestLength = $final_bestLength;
	      
	      print RELTAX $reltax_output . "\n";
	      #print TAXONOMY $writeQuery . "\t" . $reltax_output . "\n";
	    }	
	    
	    print TAXONOMY $writeQuery . "\t" . $agreement . "\t" . substr($bestIdentity,0,5) . "\t" . $bestLength . "\t" . substr($confidence,0,5) . "\n"; # Print taxonomic prediction
	  

	  }
	}

	if ($scoring_model eq "old") { # This is how version prior to Metaxa2 2.2 handled the division into domain files... From 2.2 this division is instead based on the taxonomic classification above
	  
	  ## Add the information on how many points each rRNA type collected to one list
	  push(@hitTypes, "$Atype A");
	  push(@hitTypes, "$Btype B");
	  push(@hitTypes, "$Etype E");
	  push(@hitTypes, "$Mtype M");
	  push(@hitTypes, "$Ntype N");
	  push(@hitTypes, "$Ctype C");
	  
	  $geneType = uc($gene);
	  @sortedHits = sort { $b <=> $a } @hitTypes; # Sort the list of rRNA types and counts numerically descending
	  ($bestHits, $bestType) = split(' ',@sortedHits[0]); # Get the type and number of hits for the top rRNA type
	  ($secondHits, $secondType) = split(' ',@sortedHits[1]);	# Get the type and number of hits for the second rRNA type
	  if ($bestHits == 0) {	  # If there was no blast hits at all
	    if ($lastQuery ne "") { # If the query is no empty
	      if ($queryType ne "") { # If the rRNA type of the query is not empty
		if ($queryType eq "A") { # If the rRNA type of the query is archaeal
		  $ssuA++; # Add one to the number of archeal rRNA sequences
		  push(@ssuAList,$writeQuery); # Add this entry to the list of archeal rRNA sequences
		  print AFASTA ">$writeQuery Archaeal $geneType rRNA"; # Write definition line to the archaea FASTA file
		  if ($guess_species == 1) { # If species should be guessed
		    print AFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		  } else {
		    print AFASTA "\n"; # Write end of definition line
		  }
		  print AFASTA "$DNA\n"; # Write the DNA sequence to the archaea FASTA file
		}
		if ($queryType eq "B") { # If the rRNA type of the query is bacterial
		  $ssuB++; # Add one to the number of bacterial rRNA sequences
		  push(@ssuBList,$writeQuery); # Add this entry to the list of bacterial rRNA sequences
		  print BFASTA ">$writeQuery Bacterial $geneType rRNA"; # Write definition line to the bacteria FASTA file
		  if ($guess_species == 1) { # If species should be guessed
		    print BFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		  } else {
		    print BFASTA "\n"; # Write end of definition line
		  }
		  print BFASTA "$DNA\n"; # Write the DNA sequence to the bacteria FASTA file
		}
		if ($queryType eq "E") { # If the rRNA type of the query is eukaryote
		  $ssuE++; # Add one to the number of eukaryote rRNA sequences
		  push(@ssuEList,$writeQuery); # Add this entry to the list of eukaryote rRNA sequences
		  print EFASTA ">$writeQuery Eukaryotic $geneType rRNA"; # Write definition line to the eukaryote FASTA file
		  if ($guess_species == 1) { # If species should be guessed
		    print EFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		  } else {
		    print EFASTA "\n"; # Write end of definition line
		  }
		  print EFASTA "$DNA\n"; # Write the DNA sequence to the eukaryote FASTA file
		}
		if ($queryType eq "C") { # If the rRNA type of the query is chloroplast
		  $ssuC++; # Add one to the number of chloroplast rRNA sequences
		  push(@ssuCList,$writeQuery); # Add this entry to the list of chloroplast rRNA sequences
		  print CFASTA ">$writeQuery Chloroplast $geneType rRNA";	# Write definition line to the chloroplast FASTA file
		  if ($guess_species == 1) { # If species should be guessed
		    print CFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		  } else {
		    print CFASTA "\n"; # Write end of definition line
		  }
		  print CFASTA "$DNA\n"; # Write the DNA sequence to the chloroplast FASTA file
		}
		if ($queryType eq "M") { # If the rRNA type of the query is mitochondrial 16S
		  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
		  push(@ssuMList,$writeQuery); # Add this entry to the list of mitochondrial rRNA sequences
		  print MFASTA ">$writeQuery Mitochondrial $geneType rRNA"; # Write definition line to the mitochondria FASTA file
		  if ($guess_species == 1) { # If species should be guessed
		    print MFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		  } else {
		    print MFASTA "\n"; # Write end of definition line
		  }
		  print MFASTA "$DNA\n"; # Write the DNA sequence to the mitochondria FASTA file
		}
		if ($queryType eq "N") { # If the rRNA type of the query is mitochondrial 12S
		  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
		  push(@ssuMList,$writeQuery); # Add this entry to the list of mitochondrial rRNA sequences
		  print MFASTA ">$writeQuery Mitochondrial $geneType rRNA"; # Write definition line to the mitochondria FASTA file
		  if ($guess_species == 1) { # If species should be guessed
		    print MFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		  } else {
		    print MFASTA "\n"; # Write end of definition line
		  }
		  print MFASTA "$DNA\n"; # Write the DNA sequence to the mitochondria FASTA file
		}
	      } else { # If the query rRNA type is empty (i.e. no BLAST matches)
		if ($out_not == 1) { # If sequences without matches should be outputted
		  print NOTFOUND "$writeQuery\n";	# Write that this entry had no BLAST matches to the BLAST not-found file
		}
		$ssuU++; # Add one to the number of rRNA sequences of uncertain origin
		push(@ssuUList,$writeQuery . " #"); # Add this entry to the list of rRNA sequences of uncertain origin
		print UFASTA ">$writeQuery Unknown rRNA";	# Write definition line to the uncertain FASTA file
		if ($guess_species == 1) { # If species should be guessed
		  print UFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
		} else {
		  print UFASTA "\n"; # Write end of definition line
		}
		print UFASTA "$DNA\n"; # Write the DNA sequence to the uncertain FASTA file
		
		if ($out_align eq "u") { # If only uncertain sequences should be aligned
		  open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
		  print ALNFASTA ">$writeQuery Unknown rRNA with no specfic matches in database\n"; # Write the definition line
		  print ALNFASTA "$DNA\n"; # Write the DNA sequence
		  foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
		    print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
		  }
		  close (ALNFASTA); # Close the alignment FASTA input file
		  `cp $output\_alignments/$alnQuery.unaligned.fasta $output\_alignments/$alnQuery.aligned.fasta 2>/dev/null`; # As there should be only one sequence in this file, MAFFT will refuse to align it, so we instead just create a copy of it as the "aligned" file
		}
	      }
	    
	      if ($out_align eq "a") { # If all sequences should be aligned
		open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
		print ALNFASTA ">$writeQuery Unknown rRNA with no specfic matches in database\n";	# Write the definition line
		print ALNFASTA "$DNA\n"; # Write the DNA sequence
		foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
		  print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
		}
		close (ALNFASTA);	# Close the alignment FASTA input file
		`cp $output\_alignments/$alnQuery.unaligned.fasta $output\_alignments/$alnQuery.aligned.fasta 2>/dev/null`; # As there should be only one sequence in this file, MAFFT will refuse to align it, so we instead just create a copy of it as the "aligned" file
	      }
	    }
	  } else {		# If there were BLAST matches
	    $geneType = uc($gene);
	    if (($geneType eq "SSU") || ($geneType eq "LSU")) {
	      $geneType = $geneType . " rRNA";
	    }
	    $ssuDB++; # Add one to the number of queries finding at least one match in the database
	    if (($secondHits == 0) || ($bestHits > $secondHits + $M)) { # If only one rRNA type occurs, or the best type has by far the best score...
	      
	      if (($queryType eq $bestType) || ($queryType eq "")) { # If the query type and the best found type are the same, or if the query type is empty, then trust the best found type
		($guessType, $guessRank, $guessSpecies, $guessScore, $guessEval) = split('\t',@hits[0]); # Split the best hit data into variables
		if ($bestType eq "A") { # If the most likely rRNA type is archaea
		  $ssuA++; # Add one to the number of archeal rRNA sequences
		  push(@ssuAList,$writeQuery); # Add this entry to the list of archeal rRNA sequences
		  print AFASTA ">$writeQuery Archaeal $geneType";	# Write FASTA definition line
		  if ($guess_species == 1) { # If species guessing is on
		    print AFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
		  } else {
		    print AFASTA "\n"; # Write new line
		  }
		  print AFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "B") { # If the most likely rRNA type is bacteria
		  $ssuB++; # Add one to the number of bacterial rRNA sequences
		  push(@ssuBList,$writeQuery); # Add this entry to the list of bacterial rRNA sequences
		  print BFASTA ">$writeQuery Bacterial $geneType"; # Write FASTA definition line
		  if ($guess_species == 1) { # If species guessing is on
		    print BFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
		  } else {
		    print BFASTA "\n"; # Write new line
		  }
		  print BFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "E") { # If the most likely rRNA type is eukaryote
		  $ssuE++; # Add one to the number of eukaryote rRNA sequences
		  push(@ssuEList,$writeQuery); # Add this entry to the list of eukaryote rRNA sequences
		  print EFASTA ">$writeQuery Eukaryotic $geneType"; # Write FASTA definition line
		  if ($guess_species == 1) { # If species guessing is on
		    print EFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
		  } else {
		    print EFASTA "\n"; # Write new line
		  }
		  print EFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "C") { # If the most likely rRNA type is chloroplast
		  $ssuC++; # Add one to the number of chloroplast rRNA sequences
		  push(@ssuCList,$writeQuery); # Add this entry to the list of chloroplast rRNA sequences
		  print CFASTA ">$writeQuery Chloroplast $geneType"; # Write FASTA definition line
		  if ($guess_species == 1) { # If species guessing is on
		    print CFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
		  } else {
		    print CFASTA "\n"; # Write new line
		  }
		  print CFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "M") { # If the most likely rRNA type is mitochondrial 16S
		  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
		  push(@ssuMList,$writeQuery); # Add this entry to the list of mitochondrial rRNA sequences
		  print MFASTA ">$writeQuery Mitochondrial $geneType"; # Write FASTA definition line
		  if ($guess_species == 1) { # If species guessing is on
		    print MFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
		  } else {
		    print MFASTA "\n"; # Write new line
		  }
		  print MFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "N") { # If the most likely rRNA type is mitochondrial 12S
		  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
		  push(@ssuMList,$writeQuery); # Add this entry to the list of mitochondrial rRNA sequences
		  print MFASTA ">$writeQuery Mitochondrial $geneType"; # Write FASTA definition line
		  if ($guess_species == 1) { # If species guessing is on
		    print MFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
		  } else {
		    print MFASTA "\n"; # Write new line
		  }
		  print MFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($out_align eq "a") { # If all sequences should automatially be aligned
		  open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
		  print ALNFASTA ">$writeQuery $geneType sequence\n"; # Write the definition line
		  print ALNFASTA "$DNA\n"; # Write the DNA sequence
		  foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
		    print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
		  }
		  close (ALNFASTA); # Close the alignment FASTA input file
		  `mafft --maxiterate 10 $output\_alignments/$alnQuery.unaligned.fasta > $output\_alignments/$alnQuery.aligned.fasta 2>> $tempDir/mafft_log.txt`;	# Send the sequences into MAFFT for alignment
		}
	      } else { # We don't trust the found best type, because it mismatches with the query type...
		$geneType = uc($gene);
		if (($geneType eq "SSU") || ($geneType eq "LSU")) {
		  $geneType = $geneType . " rRNA";
		}
		## Set extended type string (the string going into the definition line of the FASTA file)
		if (@seqRNAType[$best] eq "A") { # If sequence is most likely archaeal
		  $extendedType = "Predicted Archaeal $geneType";
		}
		if (@seqRNAType[$best] eq "B") { # If sequence is most likely bacterial
		  $extendedType = "Predicted Bacterial $geneType";
		}
		if (@seqRNAType[$best] eq "E") { # If sequence is most likely eukaryote
		  $extendedType = "Predicted Eukaryotic $geneType";
		}
		if (@seqRNAType[$best] eq "C") { # If sequence is most likely chloroplastic
		  $extendedType = "Predicted Chloroplast $geneType";
		}
		if (@seqRNAType[$best] eq "M") { # If sequence is most likely mitochondrial 16S
		  $extendedType = "Predicted Mitochondrial $geneType";
		}
		if (@seqRNAType[$best] eq "N") { # If sequence is most likely mitochondrial 12S
		  $extendedType = "Predicted Mitochondrial $geneType";
		}
		if (@seqRNAType[$best] eq "O") { # If sequence is most likely of other origin
		  $extendedType = "Predicted $geneType";
		}
		
		($guessType, $guessRank, $guessSpecies, $guessScore, $guessEval) = split('\t',@hits[0]); # Split the best hit data into variables
		
		## Write results to FASTA files
		if ($bestType eq "A") { # If the rRNA type of the query is archaea
		  $extendedBestType = "Archaeal $geneType rRNA"; # Set extended best type to archaea
		  $ssuA++; # Add one to the number of archeal rRNA sequences
		  push(@ssuAList,$writeQuery . " #"); # Add this entry to the list of archeal rRNA sequences
		  print AFASTA ">$writeQuery Putative $extendedBestType (could possibly be $extendedQueryType)"; # Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print AFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print AFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print AFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "B") { # If the rRNA type of the query is bacteria
		  $extendedBestType = "Bacterial $geneType rRNA";	# Set extended best type to bacteria
		  $ssuB++; # Add one to the number of bacterial rRNA sequences
		  push(@ssuBList,$writeQuery . " #"); # Add this entry to the list of bacterial rRNA sequences
		  print BFASTA ">$writeQuery Putative $extendedBestType";	# Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print BFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print BFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print BFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "E") { # If the rRNA type of the query is eukaryota
		  $extendedBestType = "Eukaryotic $geneType rRNA"; # Set extended best type to eukaryota
		  $ssuE++; # Add one to the number of eukaryote rRNA sequences
		  push(@ssuEList,$writeQuery . " #"); # Add this entry to the list of eukaryote rRNA sequences
		  print EFASTA ">$writeQuery Putative $extendedBestType";	# Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print EFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print EFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print EFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "C") { # If the rRNA type of the query is chloroplast
		  $extendedBestType = "Chloroplast $geneType rRNA"; # Set extended best type to chloroplast
		  $ssuC++; # Add one to the number of chloroplast rRNA sequences
		  push(@ssuCList,$writeQuery . " #"); # Add this entry to the list of chloroplast rRNA sequences
		  print CFASTA ">$writeQuery Putative $extendedBestType";	# Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print CFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print CFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print CFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "M") { # If the rRNA type of the query is mitochondrial 16S
		  $extendedBestType = "Mitochondrial $geneType rRNA"; # Set extended best type to mitochondrial 16S
		  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
		  push(@ssuMList,$writeQuery . " #"); # Add this entry to the list of mitochondrial rRNA sequences
		  print MFASTA ">$writeQuery Putative $extendedBestType";	# Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print MFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print MFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print MFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "N") { # If the rRNA type of the query is  mitochondrial 12S
		  $extendedBestType = "Mitochondrial $geneType rRNA"; # Set extended best type to mitochondrial 12S
		  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
		  push(@ssuMList,$writeQuery . " #"); # Add this entry to the list of mitochondrial rRNA sequences
		  print MFASTA ">$writeQuery Putative $extendedBestType";	# Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print MFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print MFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print MFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		if ($bestType eq "O") { # If the rRNA type of the query is of other kind
		  $extendedBestType = "unknown rRNA"; # Set extended best type to unknown
		  $ssuU++; # Add one to the number of rRNA sequences of uncertain origin
		  push(@ssuUList,$writeQuery . " #"); # Add this entry to the list of rRNA sequences of uncertain origin
		  print UFASTA ">$writeQuery Putative $extendedBestType";	# Write definition line to FASTA file
		  if ($guess_species == 1) { # If species guessing should be made
		    print UFASTA ", best species guess: $guessSpecies #\n"; # Write the best species guess, and an uncertain flag ("#")
		  } else {
		    print UFASTA " #\n"; # Write only the uncertain flag ("#")
		  }
		  print UFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		}
		
		if (($out_align eq "u") || ($out_align eq "a")) {	# If only uncertain sequences should be aligned
		  open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to send to MAFFT for aligning
		  print ALNFASTA ">$writeQuery Unknown rRNA sequence\n"; # Write the definition line for the current sequence
		  print ALNFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		  foreach $seq (@matchSeqs) { # For each matched sequence from the BLAST search
		    print ALNFASTA $seq; # Write that sequence to the FASTA file
		  }
		  close (ALNFASTA); # Close the FASTA alignment file
		  `mafft --maxiterate 10 $output\_alignments/$alnQuery.unaligned.fasta > $output\_alignments/$alnQuery.aligned.fasta 2>> $tempDir/mafft_log.txt`;	# Send the sequences into MAFFT for alignment
		}
	      }
	    } else { # If it is hard to tell what origin the sequence belongs to, because the scores for at least two different rRNA types are to close
	      ## Set extended query type string
	      $geneType = uc($gene);
	      if (($geneType eq "SSU") || ($geneType eq "LSU")) {
		$geneType = $geneType . " rRNA";
	      }
	      if ($queryType eq "A") { # If sequence is most predicted archaeal by metaxa_x
		$extendedQueryType = "Archaeal $geneType";
	      }
	      if ($queryType eq "B") { # If sequence is most predicted bacterial by metaxa_x
		$extendedQueryType = "Bacterial $geneType";
	      }
	      if ($queryType eq "E") { # If sequence is most predicted eukaryote by metaxa_x
		$extendedQueryType = "Eukaryotic $geneType";
	      }
	      if ($queryType eq "C") { # If sequence is most predicted chloroplast by metaxa_x
		$extendedQueryType = "Chloroplast $geneType";
	      }
	      if ($queryType eq "M") { # If sequence is most predicted mitochondrial 16S by metaxa_x
		$extendedQueryType = "Mitochondrial $geneType";
	      }
	      if ($queryType eq "N") { # If sequence is most predicted mitochondrial 12S by metaxa_x
		$extendedQueryType = "Mitochondrial $geneType";
	      }
	      if ($queryType eq "O") { # If sequence is most predicted to be of other origin by metaxa_x
		$extendedQueryType = "unknown $geneType";
	      }
	      
	      ($guessType, $guessRank, $guessSpecies, $guessScore, $guessEval) = split('\t',@hits[0]); # Split the best hit data into variables
	      $ssuU++; # Add one to the number of rRNA sequences of uncertain origin
	      push(@ssuUList,$writeQuery . " #");	# Add this entry to the list of rRNA sequences of uncertain origin
	      print UFASTA ">$writeQuery $geneType of uncertain origin, best guess: $extendedQueryType\n"; # Write the definition line to the uncertain FASTA file
	      print UFASTA "$DNA\n"; # Write the DNA sequence to the uncertain FASTA file
	      
	      if (($out_align eq "u") || ($out_align eq "a")) { # If only uncertain sequences should be aligned
		open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to send to MAFFT for aligning
		print ALNFASTA ">$writeQuery Unknown $geneType sequence\n"; # Write the definition line for the current sequence
		print ALNFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
		foreach $seq (@matchSeqs) { # For each matched sequence from the BLAST search
		  print ALNFASTA $seq; # Write that sequence to the FASTA file
		}
		close (ALNFASTA);	# Close the FASTA alignment file
		`mafft --maxiterate 10 $output\_alignments/$alnQuery.unaligned.fasta > $output\_alignments/$alnQuery.aligned.fasta 2>> $tempDir/mafft_log.txt`; # Send the sequences into MAFFT for alignment
	      }
	    }
	  }
	} else {  # So this is how the new scoring model works...
	  
	  push(@hitTypes, "$Atype A");
	  push(@hitTypes, "$Btype B");
	  push(@hitTypes, "$Etype E");
	  push(@hitTypes, "$Mtype M");
	  push(@hitTypes, "$Ntype N");
	  push(@hitTypes, "$Ctype C");
	  
	  @sortedHits = sort { $b <=> $a } @hitTypes; 
	  ($bestHits, $bestType) = split(' ',@sortedHits[0]);   # Get the type and number of hits for the top rRNA type
	  ($secondHits, $secondType) = split(' ',@sortedHits[1]);   # Get the type and number of hits for the second rRNA type
	  
	  #print TAXONOMY $writeQuery . "\t" . $agreement . "\t" . substr($bestIdentity,0,5) . "\t" . $bestLength . "\t" . substr($confidence,0,5) . "\n"; # Print taxonomic prediction
	  
	  $bestType = uc(substr($agreement, 0, 1));  # Best hit is first character of agreement
	  $geneType = uc($gene);
	  if ($confidence <= @T[1]) {  # If confidence is too low for domain classification
	    if ($bestHits == 0) {  # If the query rRNA type is empty (i.e. no BLAST matches)
	      if ($out_not == 1) { # If sequences without matches should be outputted
		print NOTFOUND "$writeQuery\n";	# Write that this entry had no BLAST matches to the BLAST not-found file
	      }
	    } else {
	      $ssuDB++; # Add one to the number of queries finding at least one match in the database
	    }
	    $ssuU++; # Add one to the number of rRNA sequences of uncertain origin
	    push(@ssuUList,$writeQuery . " #"); # Add this entry to the list of rRNA sequences of uncertain origin
	    print UFASTA ">$writeQuery Unknown rRNA";	# Write definition line to the uncertain FASTA file
	    if ($guess_species == 1) { # If species should be guessed
	      print UFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	    } else {
	      print UFASTA "\n"; # Write end of definition line
	    }
	    print UFASTA "$DNA\n"; # Write the DNA sequence to the uncertain FASTA file
	    
	    if (($out_align eq "u") || ($out_align eq "a")) { # If uncertain or all sequences should be aligned
	      open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
	      print ALNFASTA ">$writeQuery Unknown rRNA with no specfic matches in database\n"; # Write the definition line
	      print ALNFASTA "$DNA\n"; # Write the DNA sequence
	      foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
		print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
	      }
	      close (ALNFASTA); # Close the alignment FASTA input file
	      `cp $output\_alignments/$alnQuery.unaligned.fasta $output\_alignments/$alnQuery.aligned.fasta 2>/dev/null`; # As there should be only one sequence in this file, MAFFT will refuse to align it, so we instead just create a copy of it as the "aligned" file
	    }
	  } else {		# If there were BLAST matches
	    $geneType = uc($gene);
	    if (($geneType eq "SSU") || ($geneType eq "LSU")) {
	      $geneType = $geneType . " rRNA";
	    }
	    $ssuDB++; # Add one to the number of queries finding at least one match in the database
	    ($guessType, $guessRank, $guessSpecies, $guessScore, $guessEval) = split('\t',@hits[0]); # Split the best hit data into variables
	    if ($bestType eq "A") { # If the most likely rRNA type is archaea
	      $ssuA++; # Add one to the number of archeal rRNA sequences
	      push(@ssuAList,$writeQuery); # Add this entry to the list of archeal rRNA sequences
	      print AFASTA ">$writeQuery Archaeal $geneType";	# Write FASTA definition line
	      if ($guess_species == 1) { # If species guessing is on
		print AFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
	      } else {
		print AFASTA "\n"; # Write new line
	      }
	      print AFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
	    }
	    if ($bestType eq "B") { # If the most likely rRNA type is bacteria
	      $ssuB++; # Add one to the number of bacterial rRNA sequences
	      push(@ssuBList,$writeQuery); # Add this entry to the list of bacterial rRNA sequences
	      print BFASTA ">$writeQuery Bacterial $geneType"; # Write FASTA definition line
	      if ($guess_species == 1) { # If species guessing is on
		print BFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
	      } else {
		print BFASTA "\n"; # Write new line
	      }
	      print BFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
	    }
	    if ($bestType eq "E") { # If the most likely rRNA type is eukaryote
	      $ssuE++; # Add one to the number of eukaryote rRNA sequences
	      push(@ssuEList,$writeQuery); # Add this entry to the list of eukaryote rRNA sequences
	      print EFASTA ">$writeQuery Eukaryotic $geneType"; # Write FASTA definition line
	      if ($guess_species == 1) { # If species guessing is on
		print EFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
	      } else {
		print EFASTA "\n"; # Write new line
	      }
	      print EFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
	    }
	    if ($bestType eq "C") { # If the most likely rRNA type is chloroplast
	      $ssuC++; # Add one to the number of chloroplast rRNA sequences
	      push(@ssuCList,$writeQuery); # Add this entry to the list of chloroplast rRNA sequences
	      print CFASTA ">$writeQuery Chloroplast $geneType"; # Write FASTA definition line
	      if ($guess_species == 1) { # If species guessing is on
		print CFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
	      } else {
		print CFASTA "\n"; # Write new line
	      }
	      print CFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
	    }
	    if ($bestType eq "M") { # If the most likely rRNA type is mitochondrial 16S
	      $ssuM++; # Add one to the number of mitochondrial rRNA sequences
	      push(@ssuMList,$writeQuery); # Add this entry to the list of mitochondrial rRNA sequences
	      print MFASTA ">$writeQuery Mitochondrial $geneType"; # Write FASTA definition line
	      if ($guess_species == 1) { # If species guessing is on
		print MFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
	      } else {
		print MFASTA "\n"; # Write new line
	      }
	      print MFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
	    }
	    if ($bestType eq "N") { # If the most likely rRNA type is mitochondrial 12S
	      $ssuM++; # Add one to the number of mitochondrial rRNA sequences
	      push(@ssuMList,$writeQuery); # Add this entry to the list of mitochondrial rRNA sequences
	      print MFASTA ">$writeQuery Mitochondrial $geneType"; # Write FASTA definition line
	      if ($guess_species == 1) { # If species guessing is on
		print MFASTA ", best species guess: $guessSpecies\n";	# Write best species guess to definition line
	      } else {
		print MFASTA "\n"; # Write new line
	      }
	      print MFASTA "$DNA\n"; # Write the DNA sequence to the FASTA file
	    }
	    if ($out_align eq "a") { # If all sequences should automatially be aligned
	      open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
	      print ALNFASTA ">$writeQuery $geneType sequence\n"; # Write the definition line
	      print ALNFASTA "$DNA\n"; # Write the DNA sequence
	      foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
		print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
	      }
	      close (ALNFASTA); # Close the alignment FASTA input file
	      `mafft --maxiterate 10 $output\_alignments/$alnQuery.unaligned.fasta > $output\_alignments/$alnQuery.aligned.fasta 2>> $tempDir/mafft_log.txt`;	# Send the sequences into MAFFT for alignment
	    }
	  }
	}  ### END OF NEW SCORING MODEL
	## Print raw data to the raw output file
	print RAWOUT "$lastQuery\t"; # Print query name
	foreach $hit (@sortedHits) { # Print info on each found hit in the BLAST database
	  print RAWOUT $hit . "; ";
	}
	print RAWOUT "\t";	    # Write a tab separator
	print RAWOUT @hits[0] . "\n"; # Write the info on the top BLAST hit
      }
    }
    
    if ($line eq "END") {
      last;
    }
  
    ## New query started...
    if ($query ne $lastQuery) { # If the query ID is not the same as the last one, this is a new query
      $ssuQueries++;	# Add one to the number of inputted queries
      undef @hits;	# Empty the hits array
      undef @hitTypes;	# Empty the hit types array
      undef @sortedHits;	# Empty the sorted hits array
      undef @matchSeqs;   # Empty the matching sequences array
      undef @matchArray;	# Empty the temporary matching sequences array
      
      ## Set the counts for all rRNA types to zero
      $Atype = 0;
      $Btype = 0;
      $Etype = 0;
      $Mtype = 0;
      $Ntype = 0;
      $Ctype = 0;
      
      #$mcd = 0;   # Reset the match countdown to zero
      $lastSubject = "";
      $queryType = substr($query,length($query) - 2, 2); # Use the last two characters of the query identifier to determine the metaxa_x-assigned origin of the sequence
      if ($queryType =~ m/\|[ABCEFMNO]/) { # If the query type begins with a "|" and ends with any of these characters "ABCEFMNO", then assume that metaxa_x did its job
	$queryType = substr($queryType,1,1); # Remove the leading "|" from the query type
	$writeQuery = substr($query,0,length($query) - 2); # Remove the last two characters ("|X") from the query identifier to restore the original query identifier for the output
      } else {  # If the query does not seem to be processed by metaxa_x
	$writeQuery = $query; # Assure that the output query identifier will be the same as the input identifier
	$queryType = ""; # Specify that there is no metaxa_x origin data for this sequence
      }
      
      ## Set a file-system friendly name for the query sequence for alignment creation later
      $alnQuery = $writeQuery;
      $alnQuery =~ s/[^0-9A-Za-z]/_/g; # Replace all special characters with a "_", to make the file system happier
      
      ## Extract the actual sequence
      $DNA = $sequences{$query};
      
      ## Add type points for the HMMER prediction
      if ($queryType eq "A") { # If query is archaeal, add HMMER-points to the A-type
	$Atype = $Atype + $H;
      }
      if ($queryType eq "B") { # If query is bacterial, add HMMER-points to the B-type
	$Btype = $Btype + $H;
      }
      if ($queryType eq "E") { # If query is eukaryotic, add HMMER-points to the E-type
	$Etype = $Etype + $H;
      }
      if ($queryType eq "C") { # If query is chloroplastic, add HMMER-points to the C-type
	$Ctype = $Ctype + $H;
      }
      if ($queryType eq "M") { # If query is mitochondrial 16S, add HMMER-points to the M-type
	$Mtype = $Mtype + $H;
      }
      if ($queryType eq "N") { # If query is mitochondrial 12S, add HMMER-points to the N-type
	$Ntype = $Ntype + $H;
      }
      
      $mcd = $M;	   # Set the match count down to the number of matches
    }
    $lastQuery = $query;		# Set the last query
    
    if (($lastSubject ne $subject) && ($lastSubject ne "")) {
      $mcd--;			#  Lower the match count down counter
    }
    $lastSubject = $subject;
    
    if ($mcd > 0) { # If we are currently counting down matches, i.e. extracting revelant hits for classification
      if ($mcd <= $M) {		# If this line should be included
	if (@matchArray[$mcd] eq "") {
	  @matchArray[$mcd] = $query . "\t" . $subject . "\t" . $identity . "\t" . $length . "\t" .  $mismatches . "\t" . $gaps . "\t" . $mEval . "\t" . $mScore . "\t" . 1;
	} else {
	  ($storedquery,$storedsubject,$storedidentity,$storedlength,$storedmismatches,$storedgaps,$storedmEval,$storedmScore,$storedcounts) = split('\t', @matchArray[$mcd]);
	  @matchArray[$mcd] = $query . "\t" . $subject . "\t" . ($identity + $storedidentity) . "\t" . ($length + $storedlength) . "\t" . ($mismatches + $storedmismatches) . "\t" . ($gaps + $storedgaps) . "\t" . ($mEval + $storedmEval) . "\t" . ($mScore + $storedmScore) . "\t" . ($storedcounts + 1);
	}
      }
    }
  }
  close BLASTOUT;			# Close the blast output file

  ## Save sequences not found in the BLAST-report
  foreach $query (keys(%inputList)) { # For all sequences that found no matches in the blast search
    
    if (defined($refHits{$query})) {
      next;
    }
    
    ## New query started...
    $ssuQueries++;	   # Add one to the number of inputted queries
    
    ## Set the counts for all rRNA types to zero
    $Atype = 0;
    $Btype = 0;
    $Etype = 0;
    $Mtype = 0;
    $Ntype = 0;
    $Ctype = 0;
    
    $queryType = substr($query,length($query) - 2, 2); # Use the last two characters of the query identifier to determine the metaxa_x-assigned origin of the sequence
    if ($queryType =~ m/\|[ABCEFMNO]/) { # If the query type begins with a "|" and ends with any of these characters "ABCEFMNO", then assume that metaxa_x did its job
      $queryType = substr($queryType,1,1); # Remove the leading "|" from the query type
      $writeQuery = substr($query,0,length($query) - 2); # Remove the last two characters ("|X") from the query identifier to restore the original query identifier for the output
    } else {    # If the query does not seem to be processed by metaxa_x
      $writeQuery = $query; # Assure that the output query identifier will be the same as the input identifier
      $queryType = ""; # Specify that there is no metaxa_x origin data for this sequence
    }
    
    ## Set a file-system friendly name for the query sequence for alignment creation later
    $alnQuery = $writeQuery;
    $alnQuery =~ s/[^0-9A-Za-z]/_/g; # Replace all special characters with a "_", to make the file system happier
    
    ## Extract the actual sequence
    $DNA = $sequences{$query};
    
    ## Add type points for the HMMER prediction
    if ($queryType eq "A") { # If query is archaeal, add HMMER-points to the A-type
      $Atype = $Atype + $H;
    }
    if ($queryType eq "B") { # If query is bacterial, add HMMER-points to the B-type
      $Btype = $Btype + $H;
    }
    if ($queryType eq "E") { # If query is eukaryotic, add HMMER-points to the E-type
      $Etype = $Etype + $H;
    }
    if ($queryType eq "C") { # If query is chloroplastic, add HMMER-points to the C-type
      $Ctype = $Ctype + $H;
    }
    if ($queryType eq "M") { # If query is mitochondrial 16S, add HMMER-points to the M-type
      $Mtype = $Mtype + $H;
    }
    if ($queryType eq "N") { # If query is mitochondrial 12S, add HMMER-points to the N-type
      $Ntype = $Ntype + $H;
    }
    
    $geneType = uc($gene);
    if (($geneType eq "SSU") || ($geneType eq "LSU")) {
      $geneType = $geneType . " rRNA";
    }
    
    if ($queryType eq "A") {	# If sequence is most likely archaeal
      $extendedType = "Predicted Archaeal $geneType";
      $extendedTax = "Archaea;Unknown Archaea";
    }
    if ($queryType eq "B") {	# If sequence is most likely bacterial
      $extendedType = "Predicted Bacterial $geneType";
      $extendedTax = "Bacteria;Unknown Bacteria";
    }
    if ($queryType eq "E") {	# If sequence is most likely eukaryote
      $extendedType = "Predicted Eukaryotic $geneType";
      $extendedTax = "Eukaryota;Unknown Eukaryote";
    }
    if ($queryType eq "C") {  # If sequence is most likely chloroplastic
      $extendedType = "Predicted Chloroplast $geneType";
      $extendedTax = "Chloroplast;Unknown Eukaryote";
    }
    if ($queryType eq "M") { # If sequence is most likely mitochondrial 16S
      $extendedType = "Predicted Mitochondrial $geneType";
      $extendedTax = "Mitochondria;Unknown Eukaryote";
    }
    if ($queryType eq "N") { # If sequence is most likely mitochondrial 12S
      $extendedType = "Predicted Mitochondrial $geneType";
      $extendedTax = "Mitochondria;Unknown Metazoa";
    }
    if ($queryType eq "O") { # If sequence is most likely of other origin
      $extendedType = "Predicted $geneType";
      $extendedTax = "Unknown";
    }
    
    
    if ($out_tax > 0) {		# If taxonomy output is on
      ## Determine taxonomic origin
      $agreement = "";
      $bestIdentity = 0;
      $bestLength = 0;
      $confidenceScore = 0;
      $confidenceDivisor = 0;
      if ($out_tax == 2) {	# If complete taxonomy output is on
	print TAXONOMY " --- " . $writeQuery . " --- " . "\n";
      }
      print TAXONOMY $writeQuery . "\t" . $extendedTax . "\t" . "N/A" . "\t" . " N/A" . "\t" . "N/A" . "\n"; # Print taxonomic prediction
    }
    
    $geneType = uc($gene);
    if (($geneType eq "SSU") || ($geneType eq "LSU")) {
      $geneType = $geneType . " rRNA";
    }
    if ($query ne "") {	    # If the query is no empty
      if ($queryType ne "") { # If the rRNA type of the query is not empty
	if ($queryType eq "A") { # If the rRNA type of the query is archaeal
	  $ssuA++;     # Add one to the number of archeal rRNA sequences
	  push(@ssuAList,$writeQuery . " #"); # Add this entry to the list of archeal rRNA sequences
	  print AFASTA ">$writeQuery Archaeal $geneType";	# Write definition line to the archaea FASTA file
	  if ($guess_species == 1) { # If species should be guessed
	    print AFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	  } else {
	    print AFASTA "\n";	# Write end of definition line
	  }
	  print AFASTA "$DNA\n"; # Write the DNA sequence to the archaea FASTA file
	}
	if ($queryType eq "B") { # If the rRNA type of the query is bacterial
	  $ssuB++;   # Add one to the number of bacterial rRNA sequences
	  push(@ssuBList,$writeQuery . " #"); # Add this entry to the list of bacterial rRNA sequences
	  print BFASTA ">$writeQuery Bacterial $geneType"; # Write definition line to the bacteria FASTA file
	  if ($guess_species == 1) { # If species should be guessed
	    print BFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	  } else {
	    print BFASTA "\n";	# Write end of definition line
	  }
	  print BFASTA "$DNA\n"; # Write the DNA sequence to the bacteria FASTA file
	}
	if ($queryType eq "E") { # If the rRNA type of the query is eukaryote
	  $ssuE++;   # Add one to the number of eukaryote rRNA sequences
	  push(@ssuEList,$writeQuery . " #"); # Add this entry to the list of eukaryote rRNA sequences
	  print EFASTA ">$writeQuery Eukaryotic $geneType"; # Write definition line to the eukaryote FASTA file
	  if ($guess_species == 1) { # If species should be guessed
	    print EFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	  } else {
	    print EFASTA "\n";	# Write end of definition line
	  }
	  print EFASTA "$DNA\n"; # Write the DNA sequence to the eukaryote FASTA file
	}
	if ($queryType eq "C") { # If the rRNA type of the query is chloroplast
	  $ssuC++; # Add one to the number of chloroplast rRNA sequences
	  push(@ssuCList,$writeQuery . " #"); # Add this entry to the list of chloroplast rRNA sequences
	  print CFASTA ">$writeQuery Chloroplast $geneType"; # Write definition line to the chloroplast FASTA file
	  if ($guess_species == 1) { # If species should be guessed
	    print CFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	  } else {
	    print CFASTA "\n";	# Write end of definition line
	  }
	  print CFASTA "$DNA\n"; # Write the DNA sequence to the chloroplast FASTA file
	}
	if ($queryType eq "M") { # If the rRNA type of the query is mitochondrial 16S
	  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
	  push(@ssuMList,$writeQuery . " #"); # Add this entry to the list of mitochondrial rRNA sequences
	  print MFASTA ">$writeQuery Mitochondrial $geneType"; # Write definition line to the mitochondria FASTA file
	  if ($guess_species == 1) { # If species should be guessed
	    print MFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	  } else {
	    print MFASTA "\n";	# Write end of definition line
	  }
	  print MFASTA "$DNA\n"; # Write the DNA sequence to the mitochondria FASTA file
	}
	if ($queryType eq "N") { # If the rRNA type of the query is mitochondrial 12S
	  $ssuM++; # Add one to the number of mitochondrial rRNA sequences
	  push(@ssuMList,$writeQuery . " #"); # Add this entry to the list of mitochondrial rRNA sequences
	  print MFASTA ">$writeQuery Mitochondrial $geneType"; # Write definition line to the mitochondria FASTA file
	  if ($guess_species == 1) { # If species should be guessed
	    print MFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	  } else {
	    print MFASTA "\n";	# Write end of definition line
	  }
	  print MFASTA "$DNA\n"; # Write the DNA sequence to the mitochondria FASTA file
	}
      } else { # If the query rRNA type is empty (i.e. no BLAST matches)
	
	$ssuU++; # Add one to the number of rRNA sequences of uncertain origin
	push(@ssuUList,$writeQuery . " #"); # Add this entry to the list of rRNA sequences of uncertain origin
	print UFASTA ">$writeQuery Unknown $geneType"; # Write definition line to the uncertain FASTA file
	if ($guess_species == 1) { # If species should be guessed
	  print UFASTA " with no specfic matches in database\n"; # Write that no species guess could be made
	} else {
	  print UFASTA "\n";	# Write end of definition line
	}
	print UFASTA "$DNA\n"; # Write the DNA sequence to the uncertain FASTA file
	
	if ($out_align eq "u") { # If only uncertain sequences should be aligned
	  open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
	  print ALNFASTA ">$writeQuery Unknown $geneType with no specfic matches in database\n"; # Write the definition line
	  print ALNFASTA "$DNA\n"; # Write the DNA sequence
	  foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
	    print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
	  }
	  close (ALNFASTA);	# Close the alignment FASTA input file
	  `cp $output\_alignments/$alnQuery.unaligned.fasta $output\_alignments/$alnQuery.aligned.fasta 2>/dev/null`; # As there should be only one sequence in this file, MAFFT will refuse to align it, so we instead just create a copy of it as the "aligned" file
	}
      }
      
      if ($out_align eq "a") {	# If all sequences should be aligned
	open (ALNFASTA, ">$output\_alignments/$alnQuery.unaligned.fasta"); # Create a FASTA file to use as input for the alignment for this query
	print ALNFASTA ">$writeQuery Unknown $geneType with no specfic matches in database\n"; # Write the definition line
	print ALNFASTA "$DNA\n";	# Write the DNA sequence
	foreach $seq (@matchSeqs) { # Go through the sequences of the BLAST matches
	  print ALNFASTA $seq; # Add the BLAST match entry to the alignment FASTA file
	}
	close (ALNFASTA);		# Close the alignment FASTA input file
	`cp $output\_alignments/$alnQuery.unaligned.fasta $output\_alignments/$alnQuery.aligned.fasta 2>/dev/null`; # As there should be only one sequence in this file, MAFFT will refuse to align it, so we instead just create a copy of it as the "aligned" file
      }
    }
    if ($out_not == 1) { # If sequences without matches should be outputted
      print NOTFOUND "$writeQuery\n"; # Write that this entry had no BLAST matches to the BLAST not-found file
    }
    
    ## Print raw data to the raw output file
    print RAWOUT "$query\t";	 # Print query name
    print RAWOUT "\t";		 # Write a tab separator
    print RAWOUT "No hits" . "\n"; # Write that there were no hits
    
  }
}

## Save results to the summary file
if ($out_sum == 1) {		# If summary file should be written
  $geneType = uc($gene);
  if (($geneType eq "SSU") || ($geneType eq "LSU")) {
    $geneType = $geneType . " rRNA";
  }
  $ssuTotal = $ssuA + $ssuB + $ssuC + $ssuE + $ssuM + $ssuU; # Add rRNAs from all different origins
  $ssuCertain = $ssuA + $ssuB + $ssuC + $ssuE + $ssuM; # Add rRNAs from all "certain" origins
  ## Write info on the found rRNA sequences to the summary file
  print SUMMARY "Number of $geneType sequences to be classified by Metaxa:  \t$ssuQueries\n";
  print SUMMARY "Number of $geneType having at least one database match:    \t$ssuDB\n";
  print SUMMARY "Number of $geneType successfully classified by Metaxa:     \t$ssuCertain\n";
  print SUMMARY "Number of uncertain classifications of $geneType sequences:\t$ssuU\n";
  if ($reference ne "") {
    print SUMMARY "Number of reference classifications of $geneType sequences:     \t$ssuREF\n";
  }
  print SUMMARY "Total number of classifications made by Metaxa:           \t$ssuTotal\n";
  print SUMMARY "Number of $geneType sequences assigned to each origin:\n";
  print SUMMARY "  Archaea:     \t$ssuA\n";
  print SUMMARY "  Bacteria:    \t$ssuB\n";
  print SUMMARY "  Eukaryota:   \t$ssuE\n";
  print SUMMARY "  Chloroplast: \t$ssuC\n";
  print SUMMARY "  Mitochondria:\t$ssuM\n";
  print SUMMARY "  Uncertain:   \t$ssuU\n";
  print SUMMARY "-----------------------------------------------------------------\n";
  ## Write lists of entries found for each origin
  print SUMMARY "Sequences of archaeal origin:\n"; # Write the header for the list
  foreach $entry (@ssuAList) {	# For each entry in the archaea list
    print SUMMARY "$entry\n";   # Write this entry to the summary file
  }
  print SUMMARY "-----------------------------------------------------------------\n";
  print SUMMARY "Sequences of bacterial origin:\n"; # Write the header for the list
  foreach $entry (@ssuBList) {	# For each entry in the bacterial list
    print SUMMARY "$entry\n";   # Write this entry to the summary file
  }
  print SUMMARY "-----------------------------------------------------------------\n";
  print SUMMARY "Sequences of eukaryote origin:\n"; # Write the header for the list
  foreach $entry (@ssuEList) {	# For each entry in the eukaryote list
    print SUMMARY "$entry\n";   # Write this entry to the summary file
  }
  print SUMMARY "-----------------------------------------------------------------\n";
  print SUMMARY "Sequences of chloroplast origin:\n"; # Write the header for the list
  foreach $entry (@ssuCList) { # For each entry in the chloroplast list
    print SUMMARY "$entry\n";  # Write this entry to the summary file
  }
  print SUMMARY "-----------------------------------------------------------------\n";
  print SUMMARY "Sequences of mitochondrial origin:\n";	# Write the header for the list
  foreach $entry (@ssuMList) { # For each entry in the mitochondria list
    print SUMMARY "$entry\n";  # Write this entry to the summary file
  }
  print SUMMARY "-----------------------------------------------------------------\n";
  print SUMMARY "Sequences of uncertain origin:\n"; # Write the header for the list
  foreach $entry (@ssuUList) {	# For each entry in the uncertain list
    print SUMMARY "$entry\n";   # Write this entry to the summary file
  }

  close (SUMMARY);		# Close the summary file
}

## Close output files
if ($out_table == 1) {		# If table output is on
  close (TABLE);		# Close the table output file
}
if ($out_not == 1) {		# If not-found output is on
  close (NOTFOUND);		# Close the not-found output file
}
if ($out_tax > 0) {		# If taxonomy output is on
  close TAXONOMY;		# Close the taxonomy output file
}
if ($out_reltax > 0) {	  # If taxonomy output is on
  close RELTAX;		  # Close the reliability taxonomy output file
}
if ($out_fasta == 1) {		# If FASTA output is on
  ## Close the FASTA output files
  close (AFASTA);
  close (BFASTA);
  close (EFASTA);
  close (MFASTA);
  close (CFASTA);
  close (UFASTA);
}
close (RAWOUT);			# Close the raw output file


## Clean up and finish

if ($save_raw == 1) {		# If raw data should be saved
  `mv $input.[0-9]* $tempDir/`; # Move split input to temp dir
} else {			# Else, discard the raw data
  `rm -r $input.[0-9]*`;		# Remove split input
}


if ($pipeline == 0) { # If metaxa_c is not called from the pipeline mode (i.e. from metaxa)
  if ($save_raw == 1) {		# If raw data should be saved
    `mv $tempDir $output\_metaxa_raw_output`; # Change the name of the temporary directory to ..._metaxa_raw_output
  } else {			# Else, discard the raw data
    `rm -rf $tempDir`;		# Remove the temporary directory
  }
}

## Get the current time and output a finished message
$now = localtime;
if ($silent == 0) {
  print STDERR "$now : Classification finished!\n";
}

if ($split_pairs == 1) {
  ## If pairs should be split into different files, do that
  $now = localtime;
  if ($silent == 0) {
    print STDERR "$now : Splitting pairs into separate files...\n";
  }
  
  @domains = ("archaea", "bacteria", "eukaryota", "mitochondria", "chloroplast", "uncertain");
  
  foreach $domain (@domains) {
    $domain_input = "$output.$domain.fasta";
    $remove_unpaired = 0;
    
    $seq = "";
    $cseq = "";
    $header = "";
    
    open (IN, $domain_input);
    open (FW, ">$output.$domain\_1.fasta");
    open (REV, ">$output.$domain\_2.fasta");
    while ($line = <IN>) {
      chomp($line);
      if (substr($line, 0, 1) eq ">") {
	
	if ($seq ne "") {
	  ($fw, $cseq) = split('NNN*', $seq);
	  
	  if (($cseq eq "") && ($remove_unpaired ne "")) {
	    # Do nothing ...
	  } else {
	    if (($fw eq "") && ($remove_unpaired ne "")) {
	      # Do nothing ...
	    } else {
	      $cseq =~ tr/[a-z]/[A-Z]/;	# Make all letters uppercase
	      $cseq =~ s/[^A-Z]//g; # Remove all non-alphabetic characters
	      $cseq =~ tr/ACGTURYSWKMBDHVN/TGCAAYRWSMKVHDBN/; # Replace all characters with its complementary base
	      $rev = reverse($cseq);
	      
	      print FW ">" . $id . "_1 " . $header . "\n";
	      print FW $fw . "\n";
	      
	      print REV ">" . $id . "_2 " . $header . "\n";
	      print REV $rev . "\n";
	    }
	  }
	}
	
	$header = $line;
	($id) = split(' ',$header);
	$id =~ s/^>//;
	$header =~ s/^[^ ]* //;
	$seq = "";
      } else {
	$seq = $seq . $line;
      }
    }
    
    if ($seq ne "") {
      ($fw, $cseq) = split('NNN*', $seq);
      $cseq =~ tr/[a-z]/[A-Z]/;	# Make all letters uppercase
      $cseq =~ s/[^A-Z]//g;	# Remove all non-alphabetic characters
      $cseq =~ tr/ACGTURYSWKMBDHVN/TGCAAYRWSMKVHDBN/; # Replace all characters with its complementary base
      $rev = reverse($cseq);
      
      print FW ">" . $id . "_1 " . $header . "\n";
      print FW $fw . "\n";
      
      print REV ">" . $id . "_2 " . $header . "\n";
      print REV $rev . "\n";
    }
    
    
    close IN;
    close FW;
    close REV;
  }
}  

## Write end time a summary file
if ($pipeline == 0) {		# If not running in pipeline mode
  if ($out_sum == 1) {		# If summary output is on
    open (SUMMARY, ">>$output.summary.txt"); # Append to the summary file
    print SUMMARY "-----------------------------------------------------------------\n";
    print SUMMARY "metaxa2_c run finished at $now.\n"; # Write ending time for the analysis
    close (SUMMARY);		# Close summary file
  }
}




## Please send beers, pizzas, cakes, fruit pies, job positions and other types of feedback to:
## johan.bengtsson [at] microbiology.se
## Looking forward to hearing from you.... visit my website: www.microbiology.se for info on my research
## //Johan Bengtsson-Palme, December 2010 - January 2018
